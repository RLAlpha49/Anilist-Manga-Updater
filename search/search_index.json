{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> <p></p>"},{"location":"#anilist-manga-updater","title":"Anilist Manga Updater","text":""},{"location":"#getting-started","title":"Getting Started","text":"<p>Download the latest release and run the .exe file given.</p> <p>P.S. Due to compiling Python files using pyinstaller, certain antivirus programs give a false positive. You may need to exclude the exe file in your antivirus.</p> <p>You could also run the files yourself. Just download the ZIP file of the source code, extract it, make sure you have all the Python packages installed, and run the main.py file.</p> <p>Most buttons and objects when hovered have tooltips connected which explains the functionality and other information regarding them. Please check them if you are confused on what things do, or just contact me.</p>"},{"location":"#prerequisites","title":"Prerequisites","text":""},{"location":"#getting-list-from-kenmei","title":"Getting list from Kenmei","text":"<ol> <li> <p>In settings under the dashboard you can export your list as a .csv file.        | <code>Kenmei</code> Export</p> </li> <li> <p>Import this file into the program with the browse button</p> <ul> <li>(Optional) There is a second button for a \"Previous\" export file. This is for if you have already run the program before, import the previous export file as the file you used last time and your current one as the one you want to run now. This will find the difference between the 2 and only update what was different.</li> <li>This speeds up the program a lot, however, you need to have run the program once before to do this.</li> </ul> </li> </ol>"},{"location":"#installation","title":"Installation","text":"<ol> <li>You will need to set up an API in Anilist connected to your account. (In Settings under the developer tab)<ul> <li>Name the new client whatever you would like, I chose \"MangaUpdater\"</li> <li>Set the redirect URL to \"https://anilist.co/api/v2/oauth/pin\"</li> <li>A benefit to each person making their API client is that as long as none of the authentication information is shared, you are the sole person who has access to the account with that authentication</li> </ul> </li> <li>When running the program it will ask you for the following client ID and secret values generated from the API client. (They are saved to the config.json file)<ul> <li>DO NOT share the ID or Secret values.</li> </ul> </li> <li>The script may need you to authenticate if the token is invalid.</li> </ol> <p> | <code>Anilist</code> API Settings</p>"},{"location":"#usage","title":"Usage","text":"<p>| <code>GUI.py</code> GUI At Startup</p> <p>Currently, I use this script to update my manga list from my Kenmei account. If you have any features you would like added, please let me know.</p> <p>The script outputs 3 different text files when finished.</p> <ul> <li>One which has manga that was found to have multiple different IDs associated with it. (usually due to the name being found as a direct match in English or Romaji and others which has matches in synonyms)</li> <li>This file also gives the Anilist links to the manga so that they can be individually checked.</li> <li>The second one is manga which was found to not have any English, Romaji, or synonym name matches. (Most times this is due to translations of titles being different from the input sources and Anilist)</li> <li>You can then search these names separately on Anilist to see if you can get any results.</li> <li>The third is in a subdirectory which keeps track of how many chapters are updated each time you run the program.</li> </ul>"},{"location":"#contact","title":"Contact","text":"<p>Discord - alpha49</p> <p>Anilist - Alpha49</p>"},{"location":"API/APIRequests/","title":"APIRequests","text":"<p>This module contains functions to send API requests to Anilist's GraphQL endpoint. It includes functions to handle rate limits, set the access token, and check if the access token needs to be refreshed.</p>"},{"location":"API/APIRequests/#AnilistMangaUpdater.API.APIRequests.headers","title":"headers  <code>module-attribute</code>","text":"<pre><code>headers: dict[str, str] = {}\n</code></pre>"},{"location":"API/APIRequests/#AnilistMangaUpdater.API.APIRequests.url","title":"url  <code>module-attribute</code>","text":"<pre><code>url = 'https://graphql.anilist.co'\n</code></pre>"},{"location":"API/APIRequests/#AnilistMangaUpdater.API.APIRequests.Set_Access_Token","title":"Set_Access_Token","text":"<pre><code>Set_Access_Token(app: object) -&gt; None\n</code></pre> <p>Set the access token for the API requests.</p> <p>This function loads the configuration from a JSON file and sets the access token for the API requests. If the access token is not found in the configuration, it prints an error message. If the configuration file is not found, it prints an error message and returns.</p> PARAMETER DESCRIPTION <code>app</code> <p>The application object used to update the terminal and progress.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/API/APIRequests.py</code> <pre><code>def Set_Access_Token(app: object) -&gt; None:\n    \"\"\"\n    Set the access token for the API requests.\n\n    This function loads the configuration from a JSON file and sets the\n    access token for the API requests. If the access token is not found\n    in the configuration, it prints an error message. If the configuration\n    file is not found, it prints an error message and returns.\n\n    Parameters:\n        app: The application object used to update the terminal and progress.\n\n    Returns:\n        None\n    \"\"\"\n    global headers\n    Logger.INFO(\"Function Set_Access_Token called.\")\n    config = load_config(\"config.json\")\n    Logger.DEBUG(\"Loaded the configuration from config.json.\")\n    if config is not None:\n        try:\n            if config[\"ACCESS_TOKEN\"] is not None:\n                Logger.INFO(\"Access token found in the configuration.\")\n                # Get the access token\n                access_token = config[\"ACCESS_TOKEN\"]\n\n                # Define the headers for the API request\n                headers = {\"Authorization\": f\"Bearer {access_token}\"}\n                Logger.DEBUG(\"Defined the headers for the API request.\")\n            else:\n                Logger.WARNING(\"No access token found in the configuration.\")\n                app.update_terminal(\"No access token found.\")\n        except KeyError:\n            Logger.ERROR(\"No 'ACCESS_TOKEN' key in the configuration.\")\n            app.update_terminal(\"No 'ACCESS_TOKEN' key in the configuration.\")\n    else:\n        Logger.ERROR(\"No config file found.\")\n        app.update_terminal(\"No config file found.\")\n</code></pre>"},{"location":"API/APIRequests/#AnilistMangaUpdater.API.APIRequests.api_request","title":"api_request","text":"<pre><code>api_request(query: str, app: object, variables: Optional[Union[dict, None]] = None, retries: int = 3) -&gt; Optional[Union[dict, None]]\n</code></pre> <p>Send a POST request to the API endpoint and handle rate limits.</p> PARAMETER DESCRIPTION <code>query</code> <p>The GraphQL query to send.</p> <p> TYPE: <code>str</code> </p> <code>app</code> <p>The application object used to update the terminal and progress.</p> <p> TYPE: <code>object</code> </p> <code>variables</code> <p>The variables for the GraphQL query.</p> <p> TYPE: <code>dict</code> DEFAULT: <code>None</code> </p> <code>retries</code> <p>The number of times to retry the request if a 500 status code is received.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>The JSON response from the API if the request is successful, None otherwise.</p> <p> TYPE: <code>Optional[Union[dict, None]]</code> </p> Source code in <code>AnilistMangaUpdater/API/APIRequests.py</code> <pre><code>def api_request(\n    query: str,\n    app: object,\n    variables: Optional[Union[dict, None]] = None,\n    retries: int = 3,\n) -&gt; Optional[Union[dict, None]]:\n    \"\"\"\n    Send a POST request to the API endpoint and handle rate limits.\n\n    Parameters:\n        query (str): The GraphQL query to send.\n        app: The application object used to update the terminal and progress.\n        variables (dict, optional): The variables for the GraphQL query.\n        retries (int, optional): The number of times to retry the request if a\n            500 status code is received.\n\n    Returns:\n        dict: The JSON response from the API if the request is successful, None otherwise.\n    \"\"\"\n    global headers\n    if \"headers\" not in globals():\n        headers = {}\n\n    Logger.INFO(\"Function api_request called.\")\n    for _ in range(retries):\n        response = requests.post(\n            url,\n            json={\"query\": query, \"variables\": variables},\n            headers=headers,  # pylint: disable=E0606\n            timeout=10,\n        )\n\n        if response.status_code == 429:\n            wait_time = int(response.headers.get(\"X-RateLimit-Reset\", 0)) - int(\n                time.time()\n            )\n            wait_time = max(wait_time, 60)\n            Logger.WARNING(f\"Rate limit hit. Waiting for {wait_time} seconds.\")\n            app.update_terminal(f\"\\nRate limit hit. Waiting for {wait_time} seconds.\")\n            time.sleep(wait_time)\n            return api_request(query, app, variables)\n\n        if response.status_code == 200:\n            Logger.INFO(\"Request successful.\")\n            return response.json()\n\n        if response.status_code == 500:\n            Logger.ERROR(\n                f\"Server error, retrying request. Status code: {response.status_code}\"\n            )\n            app.update_terminal(\n                f\"\\nServer error, retrying request. Status code: {response.status_code}\"\n            )\n            time.sleep(2)\n            continue\n\n        Logger.ERROR(f\"Failed to retrieve data. Status code: {response.status_code}\")\n        app.update_terminal(\n            f\"\\nFailed to retrieve data. Status code: {response.status_code}\\n\"\n            \"Assumming title is not on list\\n\"\n        )\n        return None\n\n    Logger.ERROR(f\"Failed to retrieve data after {retries} retries.\")\n    app.update_terminal(\n        f\"\\nFailed to retrieve data after {retries} retries.\\nAssumming title is not on list\\n\"\n    )\n    return None\n</code></pre>"},{"location":"API/APIRequests/#AnilistMangaUpdater.API.APIRequests.needs_refresh","title":"needs_refresh","text":"<pre><code>needs_refresh(app: object) -&gt; Optional[Union[bool, None]]\n</code></pre> <p>Check if the access token needs to be refreshed.</p> <p>This function sends a simple query to the API to check if the access token is valid. If the status code of the response is 401 (Unauthorized) or 400 (Bad Request), it means the access token is invalid and needs to be refreshed. In this case, it returns True. Otherwise, it returns False.</p> PARAMETER DESCRIPTION <code>app</code> <p>The application object used to update the terminal and progress.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the access token needs to be refreshed, False otherwise.</p> <p> TYPE: <code>Optional[Union[bool, None]]</code> </p> Source code in <code>AnilistMangaUpdater/API/APIRequests.py</code> <pre><code>def needs_refresh(app: object) -&gt; Optional[Union[bool, None]]:\n    \"\"\"\n    Check if the access token needs to be refreshed.\n\n    This function sends a simple query to the API to check if the access token is valid.\n    If the status code of the response is 401 (Unauthorized) or 400 (Bad Request),\n    it means the access token is invalid and needs to be refreshed.\n    In this case, it returns True. Otherwise, it returns False.\n\n    Parameters:\n        app: The application object used to update the terminal and progress.\n\n    Returns:\n        bool: True if the access token needs to be refreshed, False otherwise.\n    \"\"\"\n    Logger.INFO(\"Function needs_refresh called.\")\n    # Define a simple query\n    query = Queries.VIEWER\n    Logger.DEBUG(\"Defined the query.\")\n    try:\n        # Send a POST request to the API endpoint with a timeout of 10 seconds\n        response = requests.post(\n            url, json={\"query\": query}, headers=headers, timeout=10\n        )\n        Logger.DEBUG(\"Sent the POST request.\")\n    except requests.exceptions.RequestException:\n        Logger.ERROR(\"Error: Cannot resolve graphql.anilist.co\")\n        app.update_terminal(\"Error: Cannot resolve graphql.anilist.co\")\n        app.update_terminal(\"Possibly due to internet connection\\n\")\n        return None\n\n    # If the status code is 401 (Unauthorized) or 400 (Bad Request), the access token is invalid\n    if response.status_code in {401, 400}:\n        Logger.ERROR(\"Error: Invalid Access Token\")\n        app.update_terminal(\"Error: Invalid Access Token\")\n        return True\n\n    # If the status code is not 401 or 400, the access token is valid\n    Logger.INFO(\"The access token is valid.\")\n    return False\n</code></pre>"},{"location":"API/AccessAPI/","title":"AccessAPI","text":"<p>This module contains functions and a class for accessing and manipulating a user's manga list on Anilist. It includes functions to get the user ID, retrieve the user's manga list, and get the format of a manga. It also includes the Manga class, which represents a manga with its details.</p>"},{"location":"API/AccessAPI/#AnilistMangaUpdater.API.AccessAPI.chapters_updated","title":"chapters_updated  <code>module-attribute</code>","text":"<pre><code>chapters_updated: int = 0\n</code></pre>"},{"location":"API/AccessAPI/#AnilistMangaUpdater.API.AccessAPI.status_mapping","title":"status_mapping  <code>module-attribute</code>","text":"<pre><code>status_mapping: dict[str, str] = {'reading': 'CURRENT', 'completed': 'COMPLETED', 'on_hold': 'PAUSED', 'dropped': 'DROPPED', 'plan_to_read': 'PLANNING'}\n</code></pre>"},{"location":"API/AccessAPI/#AnilistMangaUpdater.API.AccessAPI.userId","title":"userId  <code>module-attribute</code>","text":"<pre><code>userId: Union[int, None] = None\n</code></pre>"},{"location":"API/AccessAPI/#AnilistMangaUpdater.API.AccessAPI.Manga","title":"Manga","text":"<pre><code>Manga(name: str, manga_id: int, last_chapter_read: int, private_bool: str, status: str, last_read_at: str, months: str)\n</code></pre> <p>Represents a Manga with its details.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>The name of the manga.</p> <p> TYPE: <code>str</code> </p> <code>id</code> <p>The ID of the manga.</p> <p> TYPE: <code>int</code> </p> <code>last_chapter_read</code> <p>The last chapter of the manga that was read.</p> <p> TYPE: <code>int</code> </p> <code>private_bool</code> <p>A boolean indicating whether the manga is private.</p> <p> TYPE: <code>Union[bool, None]</code> </p> <code>status</code> <p>The status of the manga.</p> <p> TYPE: <code>str</code> </p> <code>last_read_at</code> <p>The date and time when the manga was last read.</p> <p> TYPE: <code>Union[datetime, None]</code> </p> <code>months</code> <p>The number of months since the manga was last read.</p> <p> TYPE: <code>str</code> </p> Source code in <code>AnilistMangaUpdater/API/AccessAPI.py</code> <pre><code>def __init__(  # pylint: disable=R0913\n    self,\n    name: str,\n    manga_id: int,\n    last_chapter_read: int,\n    private_bool: str,\n    status: str,\n    last_read_at: str,\n    months: str,\n):\n    self.name: str = name\n    self.id: int = manga_id\n    self.last_chapter_read: int = last_chapter_read\n    self.private_bool: Union[bool, None] = (\n        True if private_bool == \"Yes\" else False if private_bool == \"No\" else None\n    )\n    self.status: str = status\n    self.last_read_at: Union[datetime, None]\n    if last_read_at is None or (\n        isinstance(last_read_at, float) and math.isnan(last_read_at)\n    ):\n        self.last_read_at = None\n    else:\n        self.last_read_at = datetime.strptime(last_read_at, \"%Y-%m-%d %H:%M:%S UTC\")\n    self.months: str = months\n</code></pre>"},{"location":"API/AccessAPI/#AnilistMangaUpdater.API.AccessAPI.Manga.id","title":"id  <code>instance-attribute</code>","text":"<pre><code>id: int = manga_id\n</code></pre>"},{"location":"API/AccessAPI/#AnilistMangaUpdater.API.AccessAPI.Manga.last_chapter_read","title":"last_chapter_read  <code>instance-attribute</code>","text":"<pre><code>last_chapter_read: int = last_chapter_read\n</code></pre>"},{"location":"API/AccessAPI/#AnilistMangaUpdater.API.AccessAPI.Manga.last_read_at","title":"last_read_at  <code>instance-attribute</code>","text":"<pre><code>last_read_at: Union[datetime, None]\n</code></pre>"},{"location":"API/AccessAPI/#AnilistMangaUpdater.API.AccessAPI.Manga.months","title":"months  <code>instance-attribute</code>","text":"<pre><code>months: str = months\n</code></pre>"},{"location":"API/AccessAPI/#AnilistMangaUpdater.API.AccessAPI.Manga.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre>"},{"location":"API/AccessAPI/#AnilistMangaUpdater.API.AccessAPI.Manga.private_bool","title":"private_bool  <code>instance-attribute</code>","text":"<pre><code>private_bool: Union[bool, None] = True if private_bool == 'Yes' else False if private_bool == 'No' else None\n</code></pre>"},{"location":"API/AccessAPI/#AnilistMangaUpdater.API.AccessAPI.Manga.status","title":"status  <code>instance-attribute</code>","text":"<pre><code>status: str = status\n</code></pre>"},{"location":"API/AccessAPI/#AnilistMangaUpdater.API.AccessAPI.Get_Format","title":"Get_Format","text":"<pre><code>Get_Format(media_id: int, app: object) -&gt; Union[str, None]\n</code></pre> <p>Retrieves the format of a media item from AniList.</p> PARAMETER DESCRIPTION <code>media_id</code> <p>The ID of the media item.</p> <p> TYPE: <code>int</code> </p> <code>app</code> <p>The application object used to send the API request.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The format of the media item if the request was successful and</p> <p> TYPE: <code>Union[str, None]</code> </p> <code>Union[str, None]</code> <p>the format is not None, otherwise None.</p> Source code in <code>AnilistMangaUpdater/API/AccessAPI.py</code> <pre><code>def Get_Format(media_id: int, app: object) -&gt; Union[str, None]:\n    \"\"\"\n    Retrieves the format of a media item from AniList.\n\n    Parameters:\n        media_id (int): The ID of the media item.\n        app: The application object used to send the API request.\n\n    Returns:\n        str: The format of the media item if the request was successful and\n        the format is not None, otherwise None.\n    \"\"\"\n    Logger.INFO(f\"Function Get_Format called with media_id: {media_id}\")\n    # Define the query to get the format of the manga\n    query = Queries.FORMAT\n    variables = {\"id\": media_id}\n    data = api_request(query, app, variables)\n    Logger.DEBUG(\"Sent the API request.\")\n    # If the request was successful\n    if data:\n        Logger.INFO(\"The request was successful.\")\n        # Get the format value from the response\n        format_value = data.get(\"data\", {}).get(\"Media\", {}).get(\"format\")\n        Logger.DEBUG(f\"Got the format value from the response: {format_value}.\")\n        # Return the format value, or None if the format value is None\n        return format_value if format_value else None\n    # If the request was not successful\n    Logger.WARNING(\"The request was not successful. Returning None.\")\n    return None\n</code></pre>"},{"location":"API/AccessAPI/#AnilistMangaUpdater.API.AccessAPI.Get_User","title":"Get_User","text":"<pre><code>Get_User(app: object) -&gt; Union[int, None]\n</code></pre> <p>Retrieves the user ID from the Viewer object.</p> PARAMETER DESCRIPTION <code>app</code> <p>The application object used to send the API request.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>int</code> <p>The user ID if the request was successful and the user ID is not None, otherwise None.</p> <p> TYPE: <code>Union[int, None]</code> </p> Source code in <code>AnilistMangaUpdater/API/AccessAPI.py</code> <pre><code>def Get_User(app: object) -&gt; Union[int, None]:\n    \"\"\"\n    Retrieves the user ID from the Viewer object.\n\n    Parameters:\n        app: The application object used to send the API request.\n\n    Returns:\n        int: The user ID if the request was successful and the user ID is not None, otherwise None.\n    \"\"\"\n    Logger.INFO(\"Function Get_User called.\")\n    query = Queries.VIEWER\n    data = api_request(query, app)\n\n    if data:\n        Logger.INFO(\"The request was successful.\")\n        userId_value = data.get(\"data\", {}).get(\"Viewer\", {}).get(\"id\")\n        Logger.DEBUG(f\"Got the user ID from the response: {userId_value}.\")\n        return userId_value if userId_value else None\n\n    Logger.WARNING(\"The request was not successful.\")\n    return None\n</code></pre>"},{"location":"API/AccessAPI/#AnilistMangaUpdater.API.AccessAPI.Get_User_Manga_List","title":"Get_User_Manga_List","text":"<pre><code>Get_User_Manga_List(app: object) -&gt; list[dict[str, Union[int, str]]]\n</code></pre> <p>Retrieves the entire manga list of a user from AniList.</p> PARAMETER DESCRIPTION <code>app</code> <p>The application object used to send the API request.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>list</code> <p>The list of manga, each represented as a dictionary with 'mediaId',</p> <p> TYPE: <code>list[dict[str, Union[int, str]]]</code> </p> <code>list[dict[str, Union[int, str]]]</code> <p>'progress', and 'status' keys.</p> Source code in <code>AnilistMangaUpdater/API/AccessAPI.py</code> <pre><code>def Get_User_Manga_List(app: object) -&gt; list[dict[str, Union[int, str]]]:\n    \"\"\"\n    Retrieves the entire manga list of a user from AniList.\n\n    Parameters:\n        app: The application object used to send the API request.\n\n    Returns:\n        list: The list of manga, each represented as a dictionary with 'mediaId',\n        'progress', and 'status' keys.\n    \"\"\"\n    Logger.INFO(\"Function Get_User_Manga_List called.\")\n    query: str = Queries.MANGALIST\n    chunk: int = 0\n    per_chunk: int = 500\n    manga_list: list = []\n    user_Id: Union[int, None] = Get_User(app)\n\n    while True:\n        variables = {\"userId\": user_Id, \"chunk\": chunk, \"perChunk\": per_chunk}\n        Logger.DEBUG(f\"Sending API request with variables: {variables}\")\n        data = api_request(query, app, variables)\n\n        if data:\n            chunk_manga_list = (\n                data.get(\"data\", {}).get(\"MediaListCollection\", {}).get(\"lists\", [])\n            )\n\n            if not chunk_manga_list:\n                Logger.DEBUG(\"No more chunks in manga list. Breaking the loop.\")\n                break\n\n            manga_list += [\n                entry\n                for sublist in chunk_manga_list\n                for entry in sublist.get(\"entries\", [])\n            ]\n            Logger.DEBUG(\n                f\"Added chunk to manga list. Current list length: {len(manga_list)}\"\n            )\n            chunk += 1\n        else:\n            Logger.WARNING(\"API request returned no data. Breaking the loop.\")\n            break\n\n    return manga_list\n</code></pre>"},{"location":"API/GetAccessToken/","title":"GetAccessToken","text":"<p>This module contains functions for getting the access token and authentication code for the AniList API.</p>"},{"location":"API/GetAccessToken/#AnilistMangaUpdater.API.GetAccessToken.authorization_url","title":"authorization_url  <code>module-attribute</code>","text":"<pre><code>authorization_url = 'https://anilist.co/api/v2/oauth/authorize'\n</code></pre>"},{"location":"API/GetAccessToken/#AnilistMangaUpdater.API.GetAccessToken.Get_Access_Token","title":"Get_Access_Token","text":"<pre><code>Get_Access_Token(app: object) -&gt; Union[str, None]\n</code></pre> <p>Retrieves the AniList API access token from environment variables or opens the authorization URL in the web browser.</p> PARAMETER DESCRIPTION <code>app</code> <p>The application object.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The access token, or None if the client ID is not found.</p> <p> TYPE: <code>Union[str, None]</code> </p> Source code in <code>AnilistMangaUpdater/API/GetAccessToken.py</code> <pre><code>def Get_Access_Token(app: object) -&gt; Union[str, None]:\n    \"\"\"\n    Retrieves the AniList API access token from environment variables\n    or opens the authorization URL in the web browser.\n\n    Parameters:\n        app (object): The application object.\n\n    Returns:\n        str: The access token, or None if the client ID is not found.\n    \"\"\"\n    client_id = os.environ.get(\"ANILIST_CLIENT_ID\")\n    if client_id is None:\n        app.update_terminal(\n            \"No client ID found. Please enter your AniList client ID with the \"\n            \"'Set API Values' button.\"\n        )\n        return None\n\n    auth_url = f\"{authorization_url}?client_id={client_id}&amp;response_type=token\"\n    if platform.system() == \"Linux\":\n        app.update_terminal(\n            \"Please open the following URL in your web browser and follow the instructions:\"\n        )\n        app.update_terminal(auth_url)\n    else:\n        webbrowser.open(auth_url)\n\n    return Get_Authentication_Code()\n</code></pre>"},{"location":"API/GetAccessToken/#AnilistMangaUpdater.API.GetAccessToken.Get_Authentication_Code","title":"Get_Authentication_Code","text":"<pre><code>Get_Authentication_Code() -&gt; Union[str, None]\n</code></pre> <p>Checks for the presence of the access token in the environment variables in a loop.</p> RETURNS DESCRIPTION <code>str</code> <p>The access token once it's found.</p> <p> TYPE: <code>Union[str, None]</code> </p> Source code in <code>AnilistMangaUpdater/API/GetAccessToken.py</code> <pre><code>def Get_Authentication_Code() -&gt; Union[str, None]:\n    \"\"\"\n    Checks for the presence of the access token in the environment variables in a loop.\n\n    Returns:\n        str: The access token once it's found.\n    \"\"\"\n    while True:\n        if os.environ.get(\"ACCESS_TOKEN\") is not None:\n            return os.environ.get(\"ACCESS_TOKEN\")\n        time.sleep(0.5)\n</code></pre>"},{"location":"API/Queries/","title":"Queries","text":"<p>This module contains GraphQL queries for fetching data from the AniList API.</p> Queries <ul> <li>VIEWER: Fetches the viewer's ID and name.</li> <li>MANGALIST: Fetches a chunk of the viewer's manga list, including media ID, progress, and status.</li> <li>FORMAT: Fetches the format of a specific media item by ID.</li> </ul>"},{"location":"API/Queries/#AnilistMangaUpdater.API.queries.FORMAT","title":"FORMAT  <code>module-attribute</code>","text":"<pre><code>FORMAT: str = '\\nquery ($id: Int) {\\n        Media (id: $id) {\\n            id\\n            format\\n        }\\n    }\\n'\n</code></pre>"},{"location":"API/Queries/#AnilistMangaUpdater.API.queries.MANGALIST","title":"MANGALIST  <code>module-attribute</code>","text":"<pre><code>MANGALIST: str = '\\nquery ($userId: Int, $chunk: Int, $perChunk: Int) {\\n        MediaListCollection (userId: $userId, type: MANGA, chunk: $chunk, perChunk: $perChunk) {\\n            lists {\\n                entries {\\n                    mediaId\\n                    progress\\n                    status\\n                }\\n            }\\n        }\\n    }\\n'\n</code></pre>"},{"location":"API/Queries/#AnilistMangaUpdater.API.queries.VIEWER","title":"VIEWER  <code>module-attribute</code>","text":"<pre><code>VIEWER: str = '\\nquery {\\n        Viewer {\\n            id\\n            name\\n        }\\n    }\\n'\n</code></pre>"},{"location":"API/UpdateManga/","title":"UpdateManga","text":"<p>This module contains functions to update manga details such as status, progress, and privacy settings. It also includes functions to handle the updating process, including creating a dictionary of variables for updating, updating the status and progress of the manga, and sending the update request to the Anilist API.</p>"},{"location":"API/UpdateManga/#AnilistMangaUpdater.API.UpdateManga.Get_Chapters_Updated","title":"Get_Chapters_Updated","text":"<pre><code>Get_Chapters_Updated() -&gt; int\n</code></pre> <p>Get the number of chapters updated.</p> <p>This function returns the global variable chapters_updated which keeps track of the number of chapters updated.</p> RETURNS DESCRIPTION <code>int</code> <p>The number of chapters updated.</p> <p> TYPE: <code>int</code> </p> Source code in <code>AnilistMangaUpdater/API/UpdateManga.py</code> <pre><code>def Get_Chapters_Updated() -&gt; int:\n    \"\"\"\n    Get the number of chapters updated.\n\n    This function returns the global variable chapters_updated which keeps\n    track of the number of chapters updated.\n\n    Returns:\n        int: The number of chapters updated.\n    \"\"\"\n    Logger.INFO(\"Function Get_Chapters_Updated called.\")\n    Logger.DEBUG(f\"Returning the number of chapters updated: {chapters_updated}\")\n    return chapters_updated\n</code></pre>"},{"location":"API/UpdateManga/#AnilistMangaUpdater.API.UpdateManga.Set_Chapters_Updated","title":"Set_Chapters_Updated","text":"<pre><code>Set_Chapters_Updated() -&gt; None\n</code></pre> <p>Set the number of chapters updated to zero.</p> <p>This function sets the global variable chapters_updated to zero. It's typically used to reset the count of chapters updated.</p> Source code in <code>AnilistMangaUpdater/API/UpdateManga.py</code> <pre><code>def Set_Chapters_Updated() -&gt; None:\n    \"\"\"\n    Set the number of chapters updated to zero.\n\n    This function sets the global variable chapters_updated to zero.\n    It's typically used to reset the count of chapters updated.\n    \"\"\"\n    global chapters_updated\n    Logger.INFO(\"Function Set_Chapters_Updated called.\")\n    chapters_updated = 0\n    Logger.DEBUG(\"Set the number of chapters updated to zero.\")\n</code></pre>"},{"location":"API/UpdateManga/#AnilistMangaUpdater.API.UpdateManga.Update_Manga","title":"Update_Manga","text":"<pre><code>Update_Manga(manga: object, app: object, chapter_anilist: int, manga_status: Union[int, str, None]) -&gt; Optional[bool]\n</code></pre> <p>Updates the manga in the user's list.</p> <p>This function gets the user ID if it's not already set, updates the status of the manga, updates the variables for the manga, and updates the progress of the manga.</p> PARAMETER DESCRIPTION <code>manga</code> <p>The manga to update.</p> <p> TYPE: <code>object</code> </p> <code>app</code> <p>The application instance.</p> <p> TYPE: <code>object</code> </p> <code>chapter_anilist</code> <p>The current progress of the manga in the user's list.</p> <p> TYPE: <code>int</code> </p> <code>manga_status</code> <p>The current status of the manga in the user's list.</p> <p> TYPE: <code>Union[int, str, None]</code> </p> RETURNS DESCRIPTION <code>Optional[bool]</code> <p>None</p> Source code in <code>AnilistMangaUpdater/API/UpdateManga.py</code> <pre><code>def Update_Manga(\n    manga: object,\n    app: object,\n    chapter_anilist: int,\n    manga_status: Union[int, str, None],\n) -&gt; Optional[bool]:\n    \"\"\"\n    Updates the manga in the user's list.\n\n    This function gets the user ID if it's not already set, updates the status of the manga,\n    updates the variables for the manga, and updates the progress of the manga.\n\n    Args:\n        manga: The manga to update.\n        app: The application instance.\n        chapter_anilist: The current progress of the manga in the user's list.\n        manga_status: The current status of the manga in the user's list.\n\n    Returns:\n        None\n    \"\"\"\n    global userId\n\n    Logger.INFO(\"Function Update_Manga called.\")\n    # Get the user ID\n    if userId is None:\n        Logger.INFO(\"User ID is not set. Getting the user ID.\")\n        userId = Get_User(app)\n        Logger.DEBUG(f\"Got the user ID: {userId}\")\n\n    Logger.INFO(\"Updating the status of the manga.\")\n    manga.status = update_status(manga)\n    Logger.DEBUG(f\"Updated the status of the manga to: {manga.status}\")\n\n    Logger.INFO(\"Updating the variables for the manga.\")\n    variables_list = update_variables(manga, chapter_anilist, manga_status)\n    Logger.DEBUG(f\"Updated the variables for the manga: {variables_list}\")\n\n    Logger.INFO(\"Updating the progress of the manga.\")\n    updated = update_manga_progress(manga, app, variables_list, chapter_anilist)\n    Logger.DEBUG(\"Updated the progress of the manga.\")\n    return updated\n</code></pre>"},{"location":"API/UpdateManga/#AnilistMangaUpdater.API.UpdateManga.update_manga_progress","title":"update_manga_progress","text":"<pre><code>update_manga_progress(manga: object, app: object, variables_list: list, chapter_anilist: int) -&gt; Optional[bool]\n</code></pre> <p>Updates the progress of the given manga.</p> <p>This function sends a mutation request to the Anilist API to update the progress of the manga. It iterates over the list of variables, sends the request for each set of variables, and checks the response. If the response is successful and the last read is greater than the chapter from Anilist, updates the chapter progress and prints a message. If the response is not successful, it prints an error message and returns.</p> PARAMETER DESCRIPTION <code>manga</code> <p>The manga object whose progress is to be updated. The manga object should have 'name',</p> <p> TYPE: <code>object</code> </p> <code>app</code> <p>The application instance.</p> <p> TYPE: <code>object</code> </p> <code>variables_list</code> <p>A list of dictionaries, each containing the variables for the mutation request.</p> <p> TYPE: <code>list</code> </p> <code>chapter_anilist</code> <p>The current chapter of the manga from Anilist.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>Optional[bool]</code> <p>None</p> Source code in <code>AnilistMangaUpdater/API/UpdateManga.py</code> <pre><code>def update_manga_progress(\n    manga: object, app: object, variables_list: list, chapter_anilist: int\n) -&gt; Optional[bool]:\n    \"\"\"\n    Updates the progress of the given manga.\n\n    This function sends a mutation request to the Anilist API to update the progress of the manga.\n    It iterates over the list of variables, sends the request for each set of variables, and checks\n    the response. If the response is successful and the last read is greater than the chapter from\n    Anilist, updates the chapter progress and prints a message. If the response is not successful,\n    it prints an error message and returns.\n\n    Args:\n        manga: The manga object whose progress is to be updated. The manga object should have 'name',\n        'id', and 'last_chapter_read' attributes.\n        app: The application instance.\n        variables_list: A list of dictionaries, each containing the variables for the mutation request.\n        chapter_anilist: The current chapter of the manga from Anilist.\n\n    Returns:\n     None\n    \"\"\"\n    global chapters_updated\n    variables_mediaId = None\n\n    query = \"\"\"\n    mutation ($mediaId: Int, $status: MediaListStatus, $progress: Int, $private: Boolean) {\n        SaveMediaListEntry (mediaId: $mediaId, status: $status, progress: $progress, private: $private) {\n            id\n            status\n            progress\n            private\n        }\n    }\n    \"\"\"\n\n    update_sent = False\n\n    Logger.INFO(\"Function update_manga_progress called.\")\n    for variables in variables_list:\n        Logger.DEBUG(f\"Processing variables: {variables}\")\n        previous_mediaId = variables.get(\"mediaId\")\n        response = api_request(query, app, variables)\n        Logger.DEBUG(f\"Received response: {response}\")\n        if response:\n            Logger.INFO(\"Response is successful.\")\n            if manga.last_chapter_read is not None and (\n                manga.last_chapter_read &gt; chapter_anilist or chapter_anilist is None\n            ):\n                Logger.DEBUG(\n                    \"Last read chapter is greater than AniList chapter or AniList chapter is None.\"\n                )\n                if previous_mediaId != variables_mediaId:\n                    Logger.DEBUG(\"Previous mediaId is not equal to variables_mediaId.\")\n                    variables_mediaId = previous_mediaId\n                    message = (\n                        f\"Manga: {manga.name}({manga.id}) Has been set to chapter \"\n                        f\"{manga.last_chapter_read} from {chapter_anilist}\\n\"\n                    )\n                    Logger.INFO(message)\n                    app.update_terminal(message)\n                    chapters_updated += manga.last_chapter_read - chapter_anilist\n                    Logger.DEBUG(f\"Updated chapters_updated to: {chapters_updated}\")\n                    update_sent = True\n            else:\n                if manga.last_chapter_read is not None:\n                    message = (\n                        f\"Manga: {manga.name}({manga.id}) Has been set to chapter \"\n                        f\"{manga.last_chapter_read}\\n\"\n                    )\n                else:\n                    message = (\n                        f\"Manga: {manga.name}({manga.id}) Status has been set to \"\n                        f\"{manga.status}\\n\"\n                    )\n                Logger.DEBUG(message)\n                app.update_terminal(message)\n                break\n        else:\n            Logger.ERROR(\"Response is not successful.\")\n            app.update_terminal(\"Failed to alter data.\")\n            return None\n    if not update_sent:\n        return False\n\n    return True\n</code></pre>"},{"location":"API/UpdateManga/#AnilistMangaUpdater.API.UpdateManga.update_manga_variables","title":"update_manga_variables","text":"<pre><code>update_manga_variables(manga_id: int, progress: Optional[Union[int, None]] = None, status: Optional[Union[str, None]] = None, private: Optional[Union[bool, None]] = None) -&gt; dict\n</code></pre> <p>Creates a dictionary of variables for updating a manga.</p> PARAMETER DESCRIPTION <code>manga_id</code> <p>The ID of the manga to update.</p> <p> TYPE: <code>int</code> </p> <code>progress</code> <p>The progress of the manga. Default is None.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>status</code> <p>The status of the manga. Default is None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>private</code> <p>The privacy setting of the manga. Default is None.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary of variables for updating a manga, excluding any parameters that are None.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>AnilistMangaUpdater/API/UpdateManga.py</code> <pre><code>def update_manga_variables(\n    manga_id: int,\n    progress: Optional[Union[int, None]] = None,\n    status: Optional[Union[str, None]] = None,\n    private: Optional[Union[bool, None]] = None,\n) -&gt; dict:\n    \"\"\"\n    Creates a dictionary of variables for updating a manga.\n\n    Parameters:\n        manga_id (int): The ID of the manga to update.\n        progress (int): The progress of the manga. Default is None.\n        status (str): The status of the manga. Default is None.\n        private (bool): The privacy setting of the manga. Default is None.\n\n    Returns:\n        dict: A dictionary of variables for updating a manga, excluding any parameters that are None.\n    \"\"\"\n    Logger.INFO(\"Function update_manga_variables called.\")\n    variables = {\n        \"mediaId\": manga_id,\n        \"progress\": progress,\n        \"status\": status,\n        \"private\": private,\n    }\n    Logger.DEBUG(f\"Created the variables dictionary: {variables}\")\n    # Only return variables that are not None\n    filtered_variables = {k: v for k, v in variables.items() if v is not None}\n    Logger.DEBUG(f\"Filtered the variables dictionary: {filtered_variables}\")\n    return filtered_variables\n</code></pre>"},{"location":"API/UpdateManga/#AnilistMangaUpdater.API.UpdateManga.update_status","title":"update_status","text":"<pre><code>update_status(manga: object) -&gt; str\n</code></pre> <p>Updates the status of the given manga.</p> PARAMETER DESCRIPTION <code>manga</code> <p>The manga object whose status is to be updated. The manga object should</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The updated status of the manga.</p> <p> TYPE: <code>str</code> </p> Source code in <code>AnilistMangaUpdater/API/UpdateManga.py</code> <pre><code>def update_status(manga: object) -&gt; str:\n    \"\"\"\n    Updates the status of the given manga.\n\n    Args:\n        manga: The manga object whose status is to be updated. The manga object should\n        have 'status', 'months', and 'last_read_at' attributes.\n\n    Returns:\n        str: The updated status of the manga.\n    \"\"\"\n    if manga.last_read_at is None:\n        time_difference = timedelta.max\n    else:\n        time_difference = datetime.now() - manga.last_read_at\n\n    return (\n        \"PAUSED\"\n        if manga.status != \"plan_to_read\"\n        and int(manga.months) != 0\n        and time_difference &gt;= timedelta(days=30 * int(manga.months))\n        else status_mapping.get(manga.status.lower(), manga.status)\n    )\n</code></pre>"},{"location":"API/UpdateManga/#AnilistMangaUpdater.API.UpdateManga.update_variables","title":"update_variables","text":"<pre><code>update_variables(manga: object, chapter_anilist: Union[str, int, None], manga_status: Union[str, int, None]) -&gt; list[dict]\n</code></pre> <p>Updates the variables for the given manga.</p> PARAMETER DESCRIPTION <code>manga</code> <p>The manga object whose variables are to be updated. The manga object should</p> <p> TYPE: <code>object</code> </p> <code>chapter_anilist</code> <p>The current chapter of the manga from Anilist.</p> <p> TYPE: <code>Union[str, int, None]</code> </p> <code>manga_status</code> <p>The current status of the manga in the user's list.</p> <p> TYPE: <code>Union[str, int, None]</code> </p> RETURNS DESCRIPTION <code>list</code> <p>A list of dictionaries, each containing the variables for the mutation request.</p> <p> TYPE: <code>list[dict]</code> </p> Source code in <code>AnilistMangaUpdater/API/UpdateManga.py</code> <pre><code>def update_variables(\n    manga: object,\n    chapter_anilist: Union[str, int, None],\n    manga_status: Union[str, int, None],\n) -&gt; list[dict]:\n    \"\"\"\n    Updates the variables for the given manga.\n\n    Args:\n        manga: The manga object whose variables are to be updated. The manga object should\n        have 'status', 'last_chapter_read', 'id', and 'private_bool' attributes.\n        chapter_anilist: The current chapter of the manga from Anilist.\n        manga_status: The current status of the manga in the user's list.\n\n    Returns:\n        list: A list of dictionaries, each containing the variables for the mutation request.\n    \"\"\"\n    variables_list = []\n    manga.last_chapter_read = (\n        0\n        if manga.last_chapter_read is None and manga.last_chapter_read\n        else manga.last_chapter_read\n    )\n    if manga_status == \"COMPLETED\":\n        pass\n    elif manga.status == \"PLANNING\" or (\n        manga.status != manga_status\n        and (\n            manga.last_chapter_read is None\n            or manga.last_chapter_read &lt;= chapter_anilist\n            or chapter_anilist is None\n        )\n    ):\n        manga.last_chapter_read = (\n            0 if manga.status == \"PLANNING\" else manga.last_chapter_read\n        )\n        first_variables = update_manga_variables(\n            manga.id,\n            status=manga.status,\n            progress=(\n                0\n                if manga.status == \"PLANNING\"\n                else int(chapter_anilist) if chapter_anilist is not None else None\n            ),\n            private=manga.private_bool,\n        )\n        variables_list.append(first_variables)\n    elif manga.last_chapter_read is not None and (\n        manga.last_chapter_read &gt; chapter_anilist or chapter_anilist is None\n    ):\n        first_variables = update_manga_variables(\n            manga.id,\n            progress=((int(chapter_anilist) if chapter_anilist is not None else 0) + 1),\n            private=manga.private_bool,\n        )\n        third_variables = None\n        second_variables = None\n        if manga.status == \"PLANNING\" and ((int(chapter_anilist) if chapter_anilist is not None else 0) + 1) != manga.last_chapter_read:\n            second_variables = update_manga_variables(\n                manga.id, progress=manga.last_chapter_read\n            )\n            third_variables = update_manga_variables(manga.id, status=manga.status)\n        elif ((int(chapter_anilist) if chapter_anilist is not None else 0) + 1) != manga.last_chapter_read:\n            second_variables = update_manga_variables(\n                manga.id, status=manga.status, progress=manga.last_chapter_read\n            )\n        variables_list.extend(\n            [\n                v\n                for v in [first_variables, second_variables, third_variables]\n                if v is not None\n            ]\n        )\n    return variables_list\n</code></pre>"},{"location":"Main/GUI/","title":"GUI","text":"<p>This module contains the implementation of the main GUI for the application.</p> <p>It includes classes for the main window, buttons, and other GUI components, as well as methods for handling user input and updating the GUI.</p>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.app","title":"app  <code>module-attribute</code>","text":"<pre><code>app = App()\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.base_path","title":"base_path  <code>module-attribute</code>","text":"<pre><code>base_path = dirname(dirname(base_path))\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.config_path","title":"config_path  <code>module-attribute</code>","text":"<pre><code>config_path: str = 'config.json'\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.image1dir","title":"image1dir  <code>module-attribute</code>","text":"<pre><code>image1dir: str = join(image_directory, 'Anilist-Manga-Updater-Logo2.png')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.image_directory","title":"image_directory  <code>module-attribute</code>","text":"<pre><code>image_directory: str = join(base_path, 'Resources')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.program_thread","title":"program_thread  <code>module-attribute</code>","text":"<pre><code>program_thread: Union[Thread, None] = None\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.progress","title":"progress  <code>module-attribute</code>","text":"<pre><code>progress: float = 0\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.progress_status","title":"progress_status  <code>module-attribute</code>","text":"<pre><code>progress_status = 'Waiting...'\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.AccessTokenThread","title":"AccessTokenThread","text":"<pre><code>AccessTokenThread()\n</code></pre> <p>               Bases: <code>Thread</code></p> <p>A class that extends the threading.Thread class in Python. This class is used to create a separate thread for obtaining the access token from the Anilist API.</p> ATTRIBUTE DESCRIPTION <code>stop</code> <p>bool A flag used to stop the thread. It is initially set to False.</p> <p> </p> METHOD DESCRIPTION <code>run</code> <p>Overrides the run method of threading.Thread. It checks if the global 'app' variable is None. If it is, it logs an error and returns. Otherwise, it calls the Get_Access_Token function with 'app' as the argument.</p> <code>stop_thread</code> <p>Sets the stop flag to True, indicating that the thread should stop running.</p> <p>The stop flag is initially set to False, indicating that the thread should not be stopped.</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"\n    Initialize the thread and define a stop flag for the thread.\n\n    The stop flag is initially set to False, indicating that the thread should not be stopped.\n    \"\"\"\n    super().__init__()\n    self.stop: bool = False\n    Logger.DEBUG(\"AccessTokenThread initialized.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.AccessTokenThread.stop","title":"stop  <code>instance-attribute</code>","text":"<pre><code>stop: bool = False\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.AccessTokenThread.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the Get_Access_Token function in the thread.</p> <p>This method is called when the thread's start() method is invoked. It checks if the global 'app' variable is None. If it is, it logs an error and returns. Otherwise, it calls the Get_Access_Token function with 'app' as the argument.</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the Get_Access_Token function in the thread.\n\n    This method is called when the thread's start() method is invoked.\n    It checks if the global 'app' variable is None. If it is, it logs an error and returns.\n    Otherwise, it calls the Get_Access_Token function with 'app' as the argument.\n    \"\"\"\n    if app is None:  # pylint: disable=E0606\n        Logger.ERROR(\"App object not found.\")\n        return\n    Logger.INFO(\"AccessTokenThread started.\")\n    Get_Access_Token(app)  # pylint: disable=E0601, E0606\n    Logger.INFO(\"AccessTokenThread finished.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.AccessTokenThread.stop_thread","title":"stop_thread","text":"<pre><code>stop_thread() -&gt; None\n</code></pre> <p>Set the stop flag to True to stop the thread.</p> <p>This method can be called to stop the thread. It sets the stop flag to True, which indicates that the thread should stop running.</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def stop_thread(self) -&gt; None:\n    \"\"\"\n    Set the stop flag to True to stop the thread.\n\n    This method can be called to stop the thread. It sets the stop flag to True,\n    which indicates that the thread should stop running.\n    \"\"\"\n    self.stop = True\n    Logger.INFO(\"AccessTokenThread stopped.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App","title":"App","text":"<pre><code>App()\n</code></pre> <p>               Bases: <code>CTk</code></p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def __init__(self) -&gt; None:  # pylint: disable=R0915\n    super().__init__()\n\n    global program_thread  # pylint: disable=W0601\n    program_thread = None\n    self.after_id = None\n    self.start_time: float = 0\n    self.thread1: Union[AccessTokenThread, None] = None\n    Logger.DEBUG(\"Initialized GUI.\")\n\n    # Load the application logo\n    logo = customtkinter.CTkImage(\n        light_image=Image.open(image1dir), size=(100, 100)\n    )\n    Logger.DEBUG(\"Loaded application logo.\")\n\n    # Set the window title and size\n    self.title(\"Anilist Manga Updater\")\n    self.geometry(f\"{1100}x{700}\")\n    Logger.INFO(\"Set window title and size.\")\n\n    # Configure the grid layout for the window\n    self.grid_columnconfigure(1, weight=1)\n    self.grid_columnconfigure((2, 3), weight=0)\n    self.grid_rowconfigure((0, 1, 2), weight=1)\n    Logger.DEBUG(\"Configured grid layout for the window.\")\n\n    # Create a sidebar frame for the window\n    self.sidebar_frame = customtkinter.CTkFrame(self, width=140, corner_radius=0)\n    self.sidebar_frame.grid(row=0, column=0, rowspan=9, sticky=\"nsew\")\n    self.sidebar_frame.grid_rowconfigure(7, weight=1)\n    Logger.DEBUG(\"Created sidebar frame for the window.\")\n\n    # Add the application logo and title to the sidebar\n    self.logo_label = customtkinter.CTkLabel(\n        self.sidebar_frame, image=logo, text=\"\"\n    )  # display image with a CTkLabel\n    self.logo_label.grid(row=0, column=0, padx=20, pady=(10, 10))\n    self.title_label = customtkinter.CTkLabel(\n        self.sidebar_frame,\n        text=\"Anilist Manga\\nUpdater\",\n        font=customtkinter.CTkFont(size=22, weight=\"bold\"),\n    )\n    self.title_label.grid(row=1, column=0, padx=20, pady=(0, 10))\n    Logger.INFO(\"Added application logo and title to the sidebar.\")\n\n    # Add buttons to the sidebar for various actions\n    self.start_button = customtkinter.CTkButton(\n        self.sidebar_frame,\n        command=self.start_button_clicked,\n        text=\"Start\",\n        font=customtkinter.CTkFont(size=18),\n    )\n    self.start_button.grid(row=2, column=0, padx=20, pady=5)\n    Logger.INFO(\"Added 'Start' button to the sidebar.\")\n\n    self.api_button = customtkinter.CTkButton(\n        self.sidebar_frame,\n        command=self.open_input_dialog_event,\n        text=\"Set API Values\",\n    )\n    self.api_button.grid(row=3, column=0, padx=20, pady=5)\n    Logger.INFO(\"Added 'Set API Values' button to the sidebar.\")\n\n    self.access_token_button = customtkinter.CTkButton(\n        self.sidebar_frame,\n        command=self.access_token_button_clicked,\n        text=\"Get Access Token\",\n    )\n    self.access_token_button.grid(row=4, column=0, padx=20, pady=5)\n    Logger.INFO(\"Added 'Get Access Token' button to the sidebar.\")\n\n    self.month_button = customtkinter.CTkButton(\n        self.sidebar_frame, command=self.month_button_clicked, text=\"Set Months\"\n    )\n    self.month_button.grid(row=5, column=0, padx=20, pady=5)\n    Logger.INFO(\"Added 'Set Months' button to the sidebar.\")\n\n    self.private_button = customtkinter.CTkButton(\n        self.sidebar_frame,\n        command=self.private_button_clicked,\n        text=\"Private Value\",\n    )\n    self.private_button.grid(row=6, column=0, padx=20, pady=5)\n    Logger.INFO(\"Added 'Private Value' button to the sidebar.\")\n\n    self.alt_titles_button = customtkinter.CTkButton(\n        self.sidebar_frame,\n        command=lambda: self.manage_alternative_titles(),  # pylint: disable=W0108\n        text=\"Manage Alt Titles\",\n    )\n    self.alt_titles_button.grid(row=7, column=0, padx=20, pady=5)\n    Logger.INFO(\"Added 'Manage Alt Titles' button to the sidebar.\")\n\n    # Create a label and option menu for the appearance mode\n    self.appearance_mode_label = customtkinter.CTkLabel(\n        self.sidebar_frame, text=\"Appearance Mode:\", anchor=\"w\"\n    )\n    self.appearance_mode_label.grid(row=8, column=0, padx=20, pady=(10, 0))\n    Logger.INFO(\"Created 'Appearance Mode' label.\")\n\n    self.appearance_mode_optionemenu = customtkinter.CTkOptionMenu(\n        self.sidebar_frame,\n        values=[\"Light\", \"Dark\", \"System\"],\n        command=change_appearance_mode_event,\n    )\n    self.appearance_mode_optionemenu.grid(row=9, column=0, padx=20, pady=(10, 0))\n    Logger.INFO(\"Created 'Appearance Mode' option menu.\")\n\n    # Create a label and option menu for the UI scaling\n    self.scaling_label = customtkinter.CTkLabel(\n        self.sidebar_frame, text=\"UI Scaling:\", anchor=\"w\"\n    )\n    self.scaling_label.grid(row=10, column=0, padx=20, pady=(5, 0))\n    Logger.INFO(\"Created 'UI Scaling' label.\")\n\n    self.scaling_optionemenu = customtkinter.CTkOptionMenu(\n        self.sidebar_frame,\n        values=[\"80%\", \"90%\", \"100%\", \"110%\", \"120%\"],\n        command=change_scaling_event,\n    )\n    self.scaling_optionemenu.grid(row=11, column=0, padx=20, pady=(10, 15))\n    Logger.INFO(\"Created 'UI Scaling' option menu.\")\n\n    # Create an exit button\n    self.exit_button = customtkinter.CTkButton(\n        self.sidebar_frame, command=on_close, text=\"Exit\"\n    )\n    self.exit_button.grid(row=12, column=0, padx=20, pady=(5, 15))\n    Logger.INFO(\"Created 'Exit' button.\")\n\n    # Create a terminal textbox\n    self.terminal = customtkinter.CTkTextbox(self, width=250, wrap=\"word\")\n    self.terminal.grid(\n        row=0,\n        column=1,\n        columnspan=3,\n        rowspan=3,\n        padx=(20, 20),\n        pady=(20, 0),\n        sticky=\"nsew\",\n    )\n    Logger.INFO(\"Created terminal textbox.\")\n\n    # Create time remaining label\n    self.time_remaining_label = customtkinter.CTkLabel(\n        self, text=\"Estimated Time Remaining: NaN\", anchor=\"w\"\n    )\n    self.time_remaining_label.grid(\n        row=3, column=1, padx=(20, 20), pady=(5, 5), sticky=\"nsew\"\n    )\n    Logger.INFO(\"Created 'Estimated Time Remaining' label.\")\n\n    # Create time taken label\n    self.time_taken_label = customtkinter.CTkLabel(\n        self, text=\"Time Taken: 0:00:00\", anchor=\"e\"\n    )\n    self.time_taken_label.grid(\n        row=3, column=3, padx=(20, 20), pady=(5, 5), sticky=\"nsew\"\n    )\n    Logger.INFO(\"Created 'Time Taken' label.\")\n\n    # Create a progress bar\n    self.progress_bar = customtkinter.CTkProgressBar(self, width=200, height=20)\n    self.progress_bar.grid(\n        row=4, column=1, columnspan=3, padx=(20, 20), sticky=\"nsew\"\n    )\n    self.progress_bar.set(0)\n    Logger.INFO(\"Created progress bar.\")\n\n    # Create a percent label under the progress bar\n    self.percent_label = customtkinter.CTkLabel(self, text=\"0%\", anchor=\"center\")\n    self.percent_label.grid(\n        row=5, column=1, columnspan=3, padx=(20, 20), sticky=\"nsew\"\n    )\n    Logger.INFO(\"Created percent label under the progress bar.\")\n\n    # Create a status label under the progress bar\n    self.status_label = customtkinter.CTkLabel(\n        self,\n        text=(\n            f\"Status: {progress_status[:37]}...\"\n            if len(progress_status) &gt; 40\n            else progress_status\n        ),\n    )\n    self.status_label.grid(\n        row=6, column=1, columnspan=3, padx=(20, 20), sticky=\"nsew\"\n    )\n    Logger.INFO(\"Created status label under the progress bar.\")\n\n    # Create an entry field and browse button for the previous Kenmei export file path\n    self.previous_file_path_textbox = customtkinter.CTkEntry(\n        self, placeholder_text=\"Previous Kenmei Export File Path\"\n    )\n    self.previous_file_path_textbox.grid(\n        row=7, column=1, columnspan=2, padx=(20, 0), pady=(15, 15), sticky=\"nsew\"\n    )\n    Logger.INFO(\"Created entry field for the previous Kenmei export file path.\")\n\n    self.previous_browse_button = customtkinter.CTkButton(\n        master=self,\n        fg_color=\"transparent\",\n        border_width=2,\n        text_color=(\"gray10\", \"#DCE4EE\"),\n        text=\"Browse\",\n        command=lambda: self.browse_file(self.previous_file_path_textbox, True),\n    )\n    self.previous_browse_button.grid(\n        row=7, column=3, padx=(20, 20), pady=(15, 15), sticky=\"nsew\"\n    )\n    Logger.INFO(\"Created browse button for the previous Kenmei export file path.\")\n\n    # Create an entry field and browse button for the Kenmei export file path\n    self.file_path_textbox = customtkinter.CTkEntry(\n        self, placeholder_text=\"Kenmei Export File Path\"\n    )\n    self.file_path_textbox.grid(\n        row=8, column=1, columnspan=2, padx=(20, 0), pady=(5, 15), sticky=\"nsew\"\n    )\n    Logger.INFO(\"Created entry field for the Kenmei export file path.\")\n\n    self.browse_button = customtkinter.CTkButton(\n        master=self,\n        fg_color=\"transparent\",\n        border_width=2,\n        text_color=(\"gray10\", \"#DCE4EE\"),\n        text=\"Browse\",\n        command=lambda: self.browse_file(self.file_path_textbox, False),\n    )\n    self.browse_button.grid(\n        row=8, column=3, padx=(20, 20), pady=(5, 15), sticky=\"nsew\"\n    )\n    Logger.INFO(\"Created browse button for the Kenmei export file path.\")\n\n    # Set default values for the appearance mode, UI scaling, and file path textboxes\n    self.appearance_mode_optionemenu.set(\"Dark\")\n    Logger.INFO(\"Set default appearance mode to 'Dark'.\")\n    self.scaling_optionemenu.set(\"100%\")\n    Logger.INFO(\"Set default UI scaling to '100%'.\")\n    self.previous_file_path_textbox.configure(state=\"disabled\")\n    Logger.INFO(\"Disabled previous file path textbox.\")\n    self.file_path_textbox.configure(state=\"disabled\")\n    Logger.INFO(\"Disabled file path textbox.\")\n\n    # Add a welcome message to the terminal\n    self.terminal.insert(\n        \"end\",\n        \"Welcome to Anilist Manga Updater!\\n\\n\"\n        \"Please make sure to set all values with the buttons on the left side.\\n\\n\",\n    )\n    Logger.INFO(\"Added welcome message to the terminal.\")\n    self.terminal.configure(state=\"disabled\")\n    Logger.INFO(\"Disabled terminal.\")\n\n    # Set the protocol for the window close button to call the on_close function\n    self.protocol(\"WM_DELETE_WINDOW\", on_close)\n    Logger.INFO(\"Set window close button protocol to call 'on_close' function.\")\n\n    # Initialize the file path variables\n    self.file_path = \"\"\n    Logger.INFO(\"Initialized 'file_path' variable.\")\n    self.previous_file_path = \"\"\n    Logger.INFO(\"Initialized 'previous_file_path' variable.\")\n\n    # Create tooltips for the buttons and option menus\n    self.start_button_tooltip = CTkToolTip.CTkToolTip(\n        self.start_button,\n        (\n            \"Starts the program.\\n\"\n            \"The only way to stop this is to exit the AnilistMangaUpdater with the exit button.\"\n        ),\n    )\n    Logger.INFO(\"Created tooltip for 'Start' button.\")\n    self.api_button_tooltip = CTkToolTip.CTkToolTip(\n        self.api_button,\n        \"Opens a dialog to set the API values.\\nThis is for the API's Client and Secret ID's\",\n    )\n    Logger.INFO(\"Created tooltip for 'API' button.\")\n    self.access_token_button_tooltip = CTkToolTip.CTkToolTip(\n        self.access_token_button,\n        \"Opens a dialog to get the access token.\\nThis may need to be refreshed in the future.\",\n    )\n    Logger.INFO(\"Created tooltip for 'Access Token' button.\")\n    self.month_button_tooltip = CTkToolTip.CTkToolTip(\n        self.month_button,\n        (\n            \"Opens a dialog to set the number of months.\\n\"\n            \"This checks when the last time you read a chapter was and if it was \"\n            \"after the number of months you set.\\n\"\n            \"It will change the status to Paused.\\n\"\n            \"If you want the program to ignore this set this to 0\"\n        ),\n    )\n    Logger.INFO(\"Created tooltip for 'Month' button.\")\n    self.private_button_tooltip = CTkToolTip.CTkToolTip(\n        self.private_button,\n        (\n            \"Opens a dialog to set the private value.\\n\"\n            \"This is for if you want to set the manga that you update on here \"\n            \"to private on Anilist.\\n\"\n            \"Meaning it will not show up as activity or on your list for other users.\"\n        ),\n    )\n    Logger.INFO(\"Created tooltip for 'Private' button.\")\n\n    self.appearance_mode_optionemenu_tooltip = CTkToolTip.CTkToolTip(\n        self.appearance_mode_optionemenu,\n        \"Changes the appearance mode of the application.\",\n    )\n    Logger.INFO(\"Created tooltip for 'Appearance Mode' option menu.\")\n\n    self.scaling_optionemenu_tooltip = CTkToolTip.CTkToolTip(\n        self.scaling_optionemenu,\n        (\n            \"Changes the UI scaling of the application.\\n\"\n            \"You may need to resize window to fit the new scaling.\"\n        ),\n    )\n    Logger.INFO(\"Created tooltip for 'UI Scaling' option menu.\")\n\n    self.exit_button_tooltip = CTkToolTip.CTkToolTip(\n        self.exit_button,\n        (\n            \"Exits the application.\\n\"\n            \"Please use this to exit program.\\n\"\n            \"It is possible that the application will still run if you just \"\n            \"close the window rather than use this button.\"\n        ),\n    )\n    Logger.INFO(\"Created tooltip for 'Exit' button.\")\n\n    self.previous_file_path_textbox_tooltip = CTkToolTip.CTkToolTip(\n        self.previous_file_path_textbox,\n        \"Displays the path of the previous Kenmei export file. (Optional)\",\n    )\n    Logger.INFO(\"Created tooltip for 'Previous Kenmei Export File Path' textbox.\")\n\n    self.previous_browse_button_tooltip = CTkToolTip.CTkToolTip(\n        self.previous_browse_button,\n        \"Opens a file dialog to select the previous Kenmei export file. (Optional)\",\n    )\n    Logger.INFO(\n        \"Created tooltip for 'Previous Kenmei Export File Path' browse button.\"\n    )\n\n    self.file_path_textbox_tooltip = CTkToolTip.CTkToolTip(\n        self.file_path_textbox, \"Displays the path of the Kenmei export file.\"\n    )\n    Logger.INFO(\"Created tooltip for 'Kenmei Export File Path' textbox.\")\n\n    self.browse_button_tooltip = CTkToolTip.CTkToolTip(\n        self.browse_button, \"Opens a file dialog to select the Kenmei export file.\"\n    )\n    Logger.INFO(\"Created tooltip for 'Kenmei Export File Path' browse button.\")\n\n    self.progress_bar_tooltip = CTkToolTip.CTkToolTip(\n        self.progress_bar, f\"{round((progress * 100), 1)}%\"\n    )\n    Logger.INFO(\"Created tooltip for progress bar.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.access_token_button","title":"access_token_button  <code>instance-attribute</code>","text":"<pre><code>access_token_button = CTkButton(sidebar_frame, command=access_token_button_clicked, text='Get Access Token')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.access_token_button_tooltip","title":"access_token_button_tooltip  <code>instance-attribute</code>","text":"<pre><code>access_token_button_tooltip = CTkToolTip(access_token_button, 'Opens a dialog to get the access token.\\nThis may need to be refreshed in the future.')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.after_id","title":"after_id  <code>instance-attribute</code>","text":"<pre><code>after_id = None\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.alt_titles_button","title":"alt_titles_button  <code>instance-attribute</code>","text":"<pre><code>alt_titles_button = CTkButton(sidebar_frame, command=lambda: manage_alternative_titles(), text='Manage Alt Titles')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.api_button","title":"api_button  <code>instance-attribute</code>","text":"<pre><code>api_button = CTkButton(sidebar_frame, command=open_input_dialog_event, text='Set API Values')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.api_button_tooltip","title":"api_button_tooltip  <code>instance-attribute</code>","text":"<pre><code>api_button_tooltip = CTkToolTip(api_button, \"Opens a dialog to set the API values.\\nThis is for the API's Client and Secret ID's\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.appearance_mode_label","title":"appearance_mode_label  <code>instance-attribute</code>","text":"<pre><code>appearance_mode_label = CTkLabel(sidebar_frame, text='Appearance Mode:', anchor='w')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.appearance_mode_optionemenu","title":"appearance_mode_optionemenu  <code>instance-attribute</code>","text":"<pre><code>appearance_mode_optionemenu = CTkOptionMenu(sidebar_frame, values=['Light', 'Dark', 'System'], command=change_appearance_mode_event)\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.appearance_mode_optionemenu_tooltip","title":"appearance_mode_optionemenu_tooltip  <code>instance-attribute</code>","text":"<pre><code>appearance_mode_optionemenu_tooltip = CTkToolTip(appearance_mode_optionemenu, 'Changes the appearance mode of the application.')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.browse_button","title":"browse_button  <code>instance-attribute</code>","text":"<pre><code>browse_button = CTkButton(master=self, fg_color='transparent', border_width=2, text_color=('gray10', '#DCE4EE'), text='Browse', command=lambda: browse_file(file_path_textbox, False))\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.browse_button_tooltip","title":"browse_button_tooltip  <code>instance-attribute</code>","text":"<pre><code>browse_button_tooltip = CTkToolTip(browse_button, 'Opens a file dialog to select the Kenmei export file.')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.exit_button","title":"exit_button  <code>instance-attribute</code>","text":"<pre><code>exit_button = CTkButton(sidebar_frame, command=on_close, text='Exit')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.exit_button_tooltip","title":"exit_button_tooltip  <code>instance-attribute</code>","text":"<pre><code>exit_button_tooltip = CTkToolTip(exit_button, 'Exits the application.\\nPlease use this to exit program.\\nIt is possible that the application will still run if you just close the window rather than use this button.')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.file_path","title":"file_path  <code>instance-attribute</code>","text":"<pre><code>file_path = ''\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.file_path_textbox","title":"file_path_textbox  <code>instance-attribute</code>","text":"<pre><code>file_path_textbox = CTkEntry(self, placeholder_text='Kenmei Export File Path')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.file_path_textbox_tooltip","title":"file_path_textbox_tooltip  <code>instance-attribute</code>","text":"<pre><code>file_path_textbox_tooltip = CTkToolTip(file_path_textbox, 'Displays the path of the Kenmei export file.')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.logo_label","title":"logo_label  <code>instance-attribute</code>","text":"<pre><code>logo_label = CTkLabel(sidebar_frame, image=logo, text='')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.month_button","title":"month_button  <code>instance-attribute</code>","text":"<pre><code>month_button = CTkButton(sidebar_frame, command=month_button_clicked, text='Set Months')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.month_button_tooltip","title":"month_button_tooltip  <code>instance-attribute</code>","text":"<pre><code>month_button_tooltip = CTkToolTip(month_button, 'Opens a dialog to set the number of months.\\nThis checks when the last time you read a chapter was and if it was after the number of months you set.\\nIt will change the status to Paused.\\nIf you want the program to ignore this set this to 0')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.percent_label","title":"percent_label  <code>instance-attribute</code>","text":"<pre><code>percent_label = CTkLabel(self, text='0%', anchor='center')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.previous_browse_button","title":"previous_browse_button  <code>instance-attribute</code>","text":"<pre><code>previous_browse_button = CTkButton(master=self, fg_color='transparent', border_width=2, text_color=('gray10', '#DCE4EE'), text='Browse', command=lambda: browse_file(previous_file_path_textbox, True))\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.previous_browse_button_tooltip","title":"previous_browse_button_tooltip  <code>instance-attribute</code>","text":"<pre><code>previous_browse_button_tooltip = CTkToolTip(previous_browse_button, 'Opens a file dialog to select the previous Kenmei export file. (Optional)')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.previous_file_path","title":"previous_file_path  <code>instance-attribute</code>","text":"<pre><code>previous_file_path = ''\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.previous_file_path_textbox","title":"previous_file_path_textbox  <code>instance-attribute</code>","text":"<pre><code>previous_file_path_textbox = CTkEntry(self, placeholder_text='Previous Kenmei Export File Path')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.previous_file_path_textbox_tooltip","title":"previous_file_path_textbox_tooltip  <code>instance-attribute</code>","text":"<pre><code>previous_file_path_textbox_tooltip = CTkToolTip(previous_file_path_textbox, 'Displays the path of the previous Kenmei export file. (Optional)')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.private_button","title":"private_button  <code>instance-attribute</code>","text":"<pre><code>private_button = CTkButton(sidebar_frame, command=private_button_clicked, text='Private Value')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.private_button_tooltip","title":"private_button_tooltip  <code>instance-attribute</code>","text":"<pre><code>private_button_tooltip = CTkToolTip(private_button, 'Opens a dialog to set the private value.\\nThis is for if you want to set the manga that you update on here to private on Anilist.\\nMeaning it will not show up as activity or on your list for other users.')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.progress_bar","title":"progress_bar  <code>instance-attribute</code>","text":"<pre><code>progress_bar = CTkProgressBar(self, width=200, height=20)\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.progress_bar_tooltip","title":"progress_bar_tooltip  <code>instance-attribute</code>","text":"<pre><code>progress_bar_tooltip = CTkToolTip(progress_bar, f'{round(progress * 100, 1)}%')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.scaling_label","title":"scaling_label  <code>instance-attribute</code>","text":"<pre><code>scaling_label = CTkLabel(sidebar_frame, text='UI Scaling:', anchor='w')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.scaling_optionemenu","title":"scaling_optionemenu  <code>instance-attribute</code>","text":"<pre><code>scaling_optionemenu = CTkOptionMenu(sidebar_frame, values=['80%', '90%', '100%', '110%', '120%'], command=change_scaling_event)\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.scaling_optionemenu_tooltip","title":"scaling_optionemenu_tooltip  <code>instance-attribute</code>","text":"<pre><code>scaling_optionemenu_tooltip = CTkToolTip(scaling_optionemenu, 'Changes the UI scaling of the application.\\nYou may need to resize window to fit the new scaling.')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.sidebar_frame","title":"sidebar_frame  <code>instance-attribute</code>","text":"<pre><code>sidebar_frame = CTkFrame(self, width=140, corner_radius=0)\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.start_button","title":"start_button  <code>instance-attribute</code>","text":"<pre><code>start_button = CTkButton(sidebar_frame, command=start_button_clicked, text='Start', font=CTkFont(size=18))\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.start_button_tooltip","title":"start_button_tooltip  <code>instance-attribute</code>","text":"<pre><code>start_button_tooltip = CTkToolTip(start_button, 'Starts the program.\\nThe only way to stop this is to exit the AnilistMangaUpdater with the exit button.')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.start_time","title":"start_time  <code>instance-attribute</code>","text":"<pre><code>start_time: float = 0\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.status_label","title":"status_label  <code>instance-attribute</code>","text":"<pre><code>status_label = CTkLabel(self, text=f'Status: {progress_status[:37]}...' if len(progress_status) &gt; 40 else progress_status)\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.terminal","title":"terminal  <code>instance-attribute</code>","text":"<pre><code>terminal = CTkTextbox(self, width=250, wrap='word')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.thread1","title":"thread1  <code>instance-attribute</code>","text":"<pre><code>thread1: Union[AccessTokenThread, None] = None\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.time_remaining_label","title":"time_remaining_label  <code>instance-attribute</code>","text":"<pre><code>time_remaining_label = CTkLabel(self, text='Estimated Time Remaining: NaN', anchor='w')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.time_taken_label","title":"time_taken_label  <code>instance-attribute</code>","text":"<pre><code>time_taken_label = CTkLabel(self, text='Time Taken: 0:00:00', anchor='e')\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.title_label","title":"title_label  <code>instance-attribute</code>","text":"<pre><code>title_label = CTkLabel(sidebar_frame, text='Anilist Manga\\nUpdater', font=CTkFont(size=22, weight='bold'))\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.access_token_button_clicked","title":"access_token_button_clicked","text":"<pre><code>access_token_button_clicked() -&gt; None\n</code></pre> <p>Handles the event when the access token button is clicked.</p> <p>This method is triggered when the user clicks on the access token button. It performs the following steps:</p> <ol> <li>Retrieves the current configuration of the application.</li> <li>Pauses the execution for 2 seconds.</li> <li>Creates a new thread for obtaining the access token from the Anilist API.</li> <li>Starts the newly created thread.</li> <li>Opens an input dialog for the user to enter the access token.</li> <li>Waits for the access token thread to finish.</li> </ol> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def access_token_button_clicked(self) -&gt; None:\n    \"\"\"\n    Handles the event when the access token button is clicked.\n\n    This method is triggered when the user clicks on the access token button. It performs the following steps:\\n\n    1. Retrieves the current configuration of the application.\n    2. Pauses the execution for 2 seconds.\n    3. Creates a new thread for obtaining the access token from the Anilist API.\n    4. Starts the newly created thread.\n    5. Opens an input dialog for the user to enter the access token.\n    6. Waits for the access token thread to finish.\n\n    Parameters:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    # Get the configuration\n    Logger.INFO(\"Getting the configuration.\")\n    Get_Config(app)\n\n    # Pause execution for 2 seconds\n    Logger.INFO(\"Pausing execution for 2 seconds.\")\n    time.sleep(2)\n\n    # Create a new thread for getting the access token\n    Logger.INFO(\"Creating a new thread for getting the access token.\")\n    self.thread1 = AccessTokenThread()\n\n    # Start the access token thread\n    Logger.INFO(\"Starting the access token thread.\")\n    self.thread1.start()\n\n    # Open the token dialog\n    Logger.INFO(\"Opening the token dialog.\")\n    self.open_token_dialog_event()\n\n    # Wait for the access token thread to finish\n    Logger.INFO(\"Waiting for the access token thread to finish.\")\n    self.thread1.join()\n    Logger.INFO(\"Access token thread finished.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.browse_file","title":"browse_file","text":"<pre><code>browse_file(entry_widget: Union[Entry, CTkEntry], is_previous: bool) -&gt; None\n</code></pre> <p>Opens a file dialog for the user to select a file, and updates the entry widget with the selected file path.</p> <p>This method prompts the user to select a file through a file dialog. The selected file path is then inserted into the provided entry widget and stored in the appropriate variable. If the user cancels the file dialog, the text of the entry widget is restored to its previous state.</p> PARAMETER DESCRIPTION <code>entry_widget</code> <p>The entry widget to be updated with</p> <p> TYPE: <code>Union[Entry, CTkEntry]</code> </p> <code>is_previous</code> <p>A flag indicating whether the selected file is a previous Kenmei</p> <p> TYPE: <code>bool</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def browse_file(\n    self,\n    entry_widget: Union[tkinter.Entry, customtkinter.CTkEntry],\n    is_previous: bool,\n) -&gt; None:\n    \"\"\"\n    Opens a file dialog for the user to select a file, and updates the entry widget with the selected file path.\n\n    This method prompts the user to select a file through a file dialog. The selected file path is then inserted\n    into the provided entry widget and stored in the appropriate variable. If the user cancels the file dialog,\n    the text of the entry widget is restored to its previous state.\n\n    Parameters:\n        entry_widget (Union[tkinter.Entry, customtkinter.CTkEntry]): The entry widget to be updated with\n        the selected file path.\n        is_previous (bool): A flag indicating whether the selected file is a previous Kenmei\n        export file. If True, the selected file path is stored in the 'previous_file_path' variable. If False,\n        it is stored in the 'file_path' variable.\n\n    Returns:\n        None\n    \"\"\"\n    # Store the current text of the entry widget\n    current_text = entry_widget.get()\n    Logger.INFO(f\"Current text in the entry widget: {current_text}\")\n\n    # Open a file dialog and get the selected file path\n    file_path = filedialog.askopenfilename()\n    Logger.INFO(f\"File path selected by the user: {file_path}\")\n\n    # Enable the entry widget and clear its current text\n    entry_widget.configure(state=\"normal\")\n    entry_widget.delete(0, \"end\")\n\n    # If the user cancels the file dialog, restore the text of the entry widget\n    if file_path == \"\":\n        Logger.WARNING(\"User cancelled the file dialog.\")\n        if current_text == \"\":\n            # If the entry widget was empty, insert the placeholder text\n            if entry_widget == self.previous_file_path_textbox:\n                entry_widget.insert(0, \"Previous Kenmei Export File Path\")\n            else:\n                entry_widget.insert(0, \"Kenmei Export File Path\")\n            Logger.INFO(\"Entry widget was empty. Inserted placeholder text.\")\n        else:\n            # If the entry widget had text, restore it\n            entry_widget.insert(0, current_text)\n            Logger.INFO(\"Restored the text in the entry widget.\")\n    else:\n        # If the user selected a file, insert the file path into the entry widget\n        entry_widget.insert(0, file_path)\n        Logger.INFO(\"Inserted the selected file path into the entry widget.\")\n        # And store the file path in the appropriate variable\n        if is_previous:\n            self.previous_file_path = file_path\n            Logger.INFO(\n                \"Stored the selected file path in the previous_file_path variable.\"\n            )\n        else:\n            self.file_path = file_path\n            Logger.INFO(\"Stored the selected file path in the file_path variable.\")\n\n    # Disable the entry widget\n    entry_widget.configure(state=\"disabled\")\n    Logger.INFO(\"Disabled the entry widget.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.get_action","title":"get_action","text":"<pre><code>get_action() -&gt; Union[str, None]\n</code></pre> <p>Get the action from the user.</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def get_action(self) -&gt; Union[str, None]:\n    \"\"\"\n    Get the action from the user.\n    \"\"\"\n    options = [\"add\", \"edit\", \"delete\"]\n    for i, option in enumerate(options, 1):\n        self.update_terminal(f\"{i}. {option}\")\n    self.update_terminal(\"\")\n\n    Logger.INFO(\"Prompting user for action selection.\")\n    action_index = simpledialog.askinteger(\n        \"Manage Alternative Titles\",\n        \"Enter the number of the option you want to select:\",\n    )\n    if action_index is None or action_index == 0 or action_index &gt; len(options):\n        Logger.WARNING(\"Invalid or no action selected by user.\")\n        return None\n    Logger.INFO(f\"User selected action: {options[action_index - 1]}\")\n    return options[action_index - 1]\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.get_original_title","title":"get_original_title","text":"<pre><code>get_original_title(alt_titles_dict) -&gt; Union[str, None]\n</code></pre> <p>Prompts the user to select an original title from the alternative titles dictionary.</p> <p>This method displays a list of original titles to the user and prompts them to select one. The user's selection is returned. If the user cancels the dialog or enters an invalid selection, the method returns None.</p> PARAMETER DESCRIPTION <code>alt_titles_dict</code> <p>The dictionary containing the original titles as keys and alternative</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The original title selected by the user, if a valid selection was made.</p> <p> TYPE: <code>Union[str, None]</code> </p> <code>None</code> <p>If the user cancelled the dialog or made an invalid selection.</p> <p> TYPE: <code>Union[str, None]</code> </p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def get_original_title(self, alt_titles_dict) -&gt; Union[str, None]:\n    \"\"\"\n    Prompts the user to select an original title from the alternative titles dictionary.\n\n    This method displays a list of original titles to the user and prompts them to select one.\n    The user's selection is returned. If the user cancels the dialog or enters an invalid selection,\n    the method returns None.\n\n    Parameters:\n        alt_titles_dict (dict): The dictionary containing the original titles as keys and alternative\n        titles as values.\n\n    Returns:\n        str: The original title selected by the user, if a valid selection was made.\n        None: If the user cancelled the dialog or made an invalid selection.\n    \"\"\"\n    titles = list(alt_titles_dict.items())\n    for i, (title, _) in enumerate(titles, 1):\n        self.update_terminal(f\"{i}. {title}\")\n\n    Logger.INFO(\"Prompting user for title selection.\")\n    title_index = simpledialog.askinteger(\n        \"Select a title\", \"Enter the number of the title you want to select:\"\n    )\n    if title_index is None or title_index == 0 or title_index &gt; len(titles):\n        Logger.WARNING(\"Invalid or no title selected by user.\")\n        return None\n    Logger.INFO(f\"User selected title: {titles[title_index - 1][0]}\")\n    return titles[title_index - 1][0]\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.manage_alternative_titles","title":"manage_alternative_titles","text":"<pre><code>manage_alternative_titles() -&gt; None\n</code></pre> <p>Manages alternative titles in the application.</p> <p>This method allows the user to add, edit, or delete alternative titles. The user interacts with the method through a series of dialog boxes and terminal prompts. The method retrieves the current alternative titles from a file, prompts the user to select an action (add, edit, or delete), and performs the selected action.</p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def manage_alternative_titles(self) -&gt; None:\n    \"\"\"\n    Manages alternative titles in the application.\n\n    This method allows the user to add, edit, or delete alternative titles. The user interacts with the method\n    through a series of dialog boxes and terminal prompts. The method retrieves the current alternative titles\n    from a file, prompts the user to select an action (add, edit, or delete), and performs the selected action.\n\n    Parameters:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    Logger.INFO(\"Starting to manage alternative titles.\")\n    alt_titles_dict = Get_Alt_Titles_From_File(alternative_titles_dict)\n    Logger.INFO(\"Retrieved alternative titles from file.\")\n    action = self.get_action()\n    if action is None:\n        Logger.WARNING(\"No action selected. Exiting manage alternative titles.\")\n        return\n\n    Logger.INFO(f\"Action selected: {action}\")\n    if action in [\"edit\", \"delete\"]:\n        original_title = self.get_original_title(alt_titles_dict)\n        if original_title is None:\n            Logger.WARNING(\n                \"No original title selected. Exiting manage alternative titles.\"\n            )\n            return\n\n        Logger.INFO(f\"Original title selected: {original_title}\")\n        if action == \"edit\":\n            Logger.INFO(\"Starting to edit alternative title.\")\n            edit_alternative_title(alt_titles_dict, original_title)\n            Logger.INFO(\"Finished editing alternative title.\")\n        elif action == \"delete\":\n            Logger.INFO(\"Starting to delete alternative title.\")\n            delete_alternative_title(alt_titles_dict, original_title)\n            Logger.INFO(\"Finished deleting alternative title.\")\n    elif action == \"add\":\n        Logger.INFO(\"Starting to add alternative title.\")\n        add_alternative_title(alt_titles_dict)\n        Logger.INFO(\"Finished adding alternative title.\")\n    Logger.INFO(\"Finished managing alternative titles.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.month_button_clicked","title":"month_button_clicked","text":"<pre><code>month_button_clicked() -&gt; None\n</code></pre> <p>Handles the event when the month button is clicked.</p> <p>This method is triggered when the user clicks on the month button. It performs the following steps:</p> <ol> <li>Opens an input dialog for the user to enter the number of months.</li> <li>If the user input is a digit, it loads the configuration, updates the number of months in the     configuration, and saves it.</li> <li>If the configuration is not found, it displays an error message and updates the terminal.</li> <li>If the user input is not a digit, it displays an error message and updates the terminal.</li> </ol> <p>Parameters: None</p> <p>Returns: None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def month_button_clicked(self) -&gt; None:\n    \"\"\"\n    Handles the event when the month button is clicked.\n\n    This method is triggered when the user clicks on the month button. It performs the following steps:\\n\n    1. Opens an input dialog for the user to enter the number of months.\n    2. If the user input is a digit, it loads the configuration, updates the number of months in the\n        configuration, and saves it.\n    3. If the configuration is not found, it displays an error message and updates the terminal.\n    4. If the user input is not a digit, it displays an error message and updates the terminal.\n\n    Parameters:\n    None\n\n    Returns:\n    None\n    \"\"\"\n    while True:\n        # Open an input dialog for the number of months\n        Logger.INFO(\"Opening input dialog for the number of months.\")\n        months = customtkinter.CTkInputDialog(\n            text=\"Type in the Number of Months:\", title=\"Months\"\n        )\n        months_value = months.get_input()\n        Logger.INFO(f\"Number of months input: {months_value}\")\n\n        # If the user input is a digit\n        if months_value.isdigit():\n            # Load the configuration\n            Logger.INFO(\"Loading configuration.\")\n            config = load_config(config_path)\n            if config is not None:\n                # Update the number of months in the configuration and save it\n                Logger.INFO(\n                    \"Updating number of months in configuration and saving it.\"\n                )\n                config[\"MONTHS\"] = months_value\n                save_config(config, config_path)\n                Logger.INFO(\"Configuration saved.\")\n                break\n\n            # If the configuration is not found, show an error message\n            Logger.ERROR(\"No configuration file found. Showing error message.\")\n            messagebox.showerror(\n                \"Error\",\n                \"No config file found. Please set the API values first.\",\n            )\n            self.update_terminal(\n                \"No config file found. Please set the API values first.\"\n            )\n            Logger.INFO(\"Updated terminal with error message.\")\n            break\n        # If the user input is not a digit, show an error message\n        Logger.WARNING(\"User input is not a digit. Showing error message.\")\n        messagebox.showerror(\"Error\", \"Canceled\")\n        self.update_terminal(\"Canceled\")\n        Logger.INFO(\"Updated terminal with cancellation message.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.open_input_dialog_event","title":"open_input_dialog_event","text":"<pre><code>open_input_dialog_event() -&gt; None\n</code></pre> <p>Opens input dialogs for the client ID and secret ID.</p> <p>This method prompts the user to input the client ID and secret ID through input dialogs. If the user cancels either dialog, a cancellation message is updated in the terminal. If the user enters both IDs, a configuration file is created and saved.</p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def open_input_dialog_event(self) -&gt; None:\n    \"\"\"\n    Opens input dialogs for the client ID and secret ID.\n\n    This method prompts the user to input the client ID and secret ID through input dialogs. If the user cancels\n    either dialog, a cancellation message is updated in the terminal. If the user enters both IDs,\n    a configuration file is created and saved.\n\n    Parameters:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    # Open input dialogs for the client ID and secret ID\n    Logger.INFO(\"Opening input dialog for the Client ID.\")\n    client_id = customtkinter.CTkInputDialog(\n        text=\"Type in the Client ID:\", title=\"Client ID\"\n    )\n    client_id_value = client_id.get_input()\n    Logger.INFO(f\"Client ID input: {client_id_value}\")\n\n    Logger.INFO(\"Opening input dialog for the Secret ID.\")\n    secret_id = customtkinter.CTkInputDialog(\n        text=\"Type in the Secret ID:\", title=\"Secret ID\"\n    )\n    secret_id_value = secret_id.get_input()\n    Logger.INFO(f\"Secret ID input: {secret_id_value}\")\n\n    # If the user cancels either dialog, update the terminal with a cancellation message\n    if client_id_value is None or secret_id_value is None:\n        Logger.WARNING(\"User cancelled the input dialog.\")\n        self.update_terminal(\"Canceled\")\n    else:\n        # If the user enters both IDs, create a configuration file and save it\n        Logger.INFO(\n            \"User entered both IDs. Creating and saving configuration file.\"\n        )\n        config = create_config(client_id_value, secret_id_value)\n        self.update_terminal(\"Configuration file created and saved.\")\n        save_config(config, config_path)\n        Logger.INFO(\"Configuration file saved.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.open_token_dialog_event","title":"open_token_dialog_event","text":"<pre><code>open_token_dialog_event() -&gt; None\n</code></pre> <p>Opens an input dialog for the user to enter the access token.</p> <p>This method prompts the user to input the access token through an input dialog. If the user cancels the dialog, an error message is displayed and the terminal is updated with a cancellation message. If the user enters the access token, the method loads the configuration file, adds the access token to it, and saves the updated configuration file. If the thread for obtaining the access token is running, it is stopped.</p> RETURNS DESCRIPTION <code>None</code> <p>None</p> RAISES DESCRIPTION <code>TypeError</code> <p>If the user cancels the input dialog.</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def open_token_dialog_event(self) -&gt; None:\n    \"\"\"\n    Opens an input dialog for the user to enter the access token.\n\n    This method prompts the user to input the access token through an input dialog. If the user cancels the dialog,\n    an error message is displayed and the terminal is updated with a cancellation message. If the user enters the\n    access token, the method loads the configuration file, adds the access token to it, and saves the updated\n    configuration file. If the thread for obtaining the access token is running, it is stopped.\n\n    Parameters:\n        None\n\n    Returns:\n        None\n\n    Raises:\n        TypeError: If the user cancels the input dialog.\n    \"\"\"\n    # Open an input dialog for the access token\n    Logger.INFO(\"Opening input dialog for the Access Token.\")\n    token = customtkinter.CTkInputDialog(\n        text=\"Type in the Access Token:\", title=\"Access Token\"\n    )\n    token_value = token.get_input()\n    Logger.INFO(f\"Access Token input: {token_value}\")\n\n    try:\n        # Load the configuration file and add the access token\n        Logger.INFO(\"Loading configuration file.\")\n        config = load_config(config_path)\n        Logger.INFO(\"Adding Access Token to configuration file.\")\n        if config is not None and isinstance(config, dict):\n            config[\"ACCESS_TOKEN\"] = token_value\n        Logger.INFO(\"Saving configuration file.\")\n        save_config(config, config_path)\n        Logger.INFO(\"Configuration file saved.\")\n        self.update_terminal(\"Access Token set.\")\n        Logger.INFO(\"Access Token set.\")\n        Set_Access_Token(app)\n        Logger.INFO(\"Set Access Token in app.\")\n        if self.thread1 is not None:\n            self.thread1.stop_thread()\n        Logger.INFO(\"Stopped thread1.\")\n    except TypeError:\n        # If the user cancels the dialog, show an error message\n        Logger.WARNING(\"User cancelled the input dialog.\")\n        messagebox.showerror(\"Error\", \"Canceled\")\n        self.update_terminal(\"Canceled\")\n        Logger.INFO(\"Updated terminal with cancellation message.\")\n        if self.thread1 is not None:\n            self.thread1.stop_thread()\n        Logger.INFO(\"Stopped thread1.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.private_button_clicked","title":"private_button_clicked","text":"<pre><code>private_button_clicked() -&gt; None\n</code></pre> <p>Handles the event when the private button is clicked.</p> <p>This method is triggered when the user clicks on the private button. It performs the following steps:</p> <ol> <li>Opens an input dialog for the user to enter the private value.</li> <li>If the user input is \"yes\" or \"no\", it loads the configuration, updates the private value in the     configuration, and saves it.</li> <li>If the configuration is not found, it displays an error message and updates the terminal.</li> <li>If the user input is not \"yes\" or \"no\", it displays an error message and updates the terminal.</li> <li>If the user cancels the dialog, it displays an error message and updates the terminal.</li> </ol> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def private_button_clicked(self) -&gt; None:\n    \"\"\"\n    Handles the event when the private button is clicked.\n\n    This method is triggered when the user clicks on the private button. It performs the following steps:\\n\n    1. Opens an input dialog for the user to enter the private value.\n    2. If the user input is \"yes\" or \"no\", it loads the configuration, updates the private value in the\n        configuration, and saves it.\n    3. If the configuration is not found, it displays an error message and updates the terminal.\n    4. If the user input is not \"yes\" or \"no\", it displays an error message and updates the terminal.\n    5. If the user cancels the dialog, it displays an error message and updates the terminal.\n\n    Parameters:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    while True:\n        # Open an input dialog for the private value\n        Logger.INFO(\"Opening input dialog for the private value.\")\n        private = customtkinter.CTkInputDialog(\n            text=\"Type in the Private Value (Yes/No):\", title=\"Private\"\n        )\n        private_value = private.get_input()\n        Logger.INFO(f\"Private value input: {private_value}\")\n\n        try:\n            # If the user input is \"yes\" or \"no\"\n            if private_value.lower() in [\"yes\", \"no\"]:\n                # Load the configuration\n                Logger.INFO(\"Loading configuration.\")\n                config = load_config(config_path)\n                if config is not None:\n                    # Update the private value in the configuration and save it\n                    Logger.INFO(\n                        \"Updating private value in configuration and saving it.\"\n                    )\n                    config[\"PRIVATE\"] = private_value\n                    save_config(config, config_path)\n                    Logger.INFO(\"Configuration saved.\")\n                    break\n                # If the configuration is not found, show an error message\n                Logger.ERROR(\"No configuration file found. Showing error message.\")\n                messagebox.showerror(\n                    \"Error\",\n                    \"No config file found. Please set the API values first.\",\n                )\n                self.update_terminal(\n                    \"No config file found. Please set the API values first.\"\n                )\n                Logger.INFO(\"Updated terminal with error message.\")\n                break\n            # If the user input is not \"yes\" or \"no\", show an error message\n            Logger.WARNING(\n                \"User input is not 'yes' or 'no'. Showing error message.\"\n            )\n            messagebox.showerror(\"Error\", \"Invalid input. Please enter Yes or No.\")\n            self.update_terminal(\"Invalid input. Please enter Yes or No.\")\n            Logger.INFO(\"Updated terminal with error message.\")\n        except AttributeError:\n            # If the user cancels the dialog, show an error message\n            Logger.WARNING(\n                \"User cancelled the input dialog. Showing error message.\"\n            )\n            messagebox.showerror(\"Error\", \"Canceled\")\n            self.update_terminal(\"Canceled\")\n            Logger.INFO(\"Updated terminal with cancellation message.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.start_button_clicked","title":"start_button_clicked","text":"<pre><code>start_button_clicked() -&gt; None\n</code></pre> <p>Handles the event when the start button is clicked.</p> <p>This method is triggered when the user clicks on the start button. It performs the following steps:</p> <pre><code>1. Checks if the program thread is already running. If it is, it returns immediately.\n2. If the program thread is not running, it imports the AnilistMangaUpdater class.\n3. Creates a new thread for the program.\n4. Starts the newly created thread.\n5. Sets the start time to the current time.\n6. Updates the time taken label.\n7. Updates the progress bar.\n8. Resets the progress to 0.\n</code></pre> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def start_button_clicked(self) -&gt; None:\n    \"\"\"\n    Handles the event when the start button is clicked.\n\n    This method is triggered when the user clicks on the start button. It performs the following steps:\\n\n        1. Checks if the program thread is already running. If it is, it returns immediately.\n        2. If the program thread is not running, it imports the AnilistMangaUpdater class.\n        3. Creates a new thread for the program.\n        4. Starts the newly created thread.\n        5. Sets the start time to the current time.\n        6. Updates the time taken label.\n        7. Updates the progress bar.\n        8. Resets the progress to 0.\n\n    Parameters:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    global progress  # pylint: disable=W0603\n    global program_thread  # pylint: disable=W0601\n\n    # Check if the thread is already running\n    Logger.INFO(\"Checking if the program thread is already running.\")\n    if program_thread is not None and program_thread.is_alive():\n        Logger.WARNING(\n            \"AnilistMangaUpdater thread is already running. Returning immediately.\"\n        )\n        return\n\n    # Import the AnilistMangaUpdater class\n    Logger.INFO(\"Importing the AnilistMangaUpdater class.\")\n    from Main.Program import Program  # pylint: disable=C0415, E0611\n\n    # Create a new thread for the program\n    Logger.INFO(\"Creating a new thread for the program.\")\n    program_thread = threading.Thread(target=Program, args=(self,))\n\n    # Start the program thread\n    Logger.INFO(\"Starting the program thread.\")\n    program_thread.start()\n\n    Logger.INFO(\"Setting the start time to the current time.\")\n    self.start_time = time.time()\n\n    Logger.INFO(\"Updating the time taken label.\")\n    self.time_taken_label.configure(text=\"Time Taken: 0:00:00\")\n\n    Logger.INFO(\"Updating the progress bar.\")\n    self.update_progress_bar()\n\n    Logger.INFO(\"Resetting the progress to 0.\")\n    progress = 0\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.update_estimated_time_remaining","title":"update_estimated_time_remaining","text":"<pre><code>update_estimated_time_remaining(estimated_time_remaining: float) -&gt; None\n</code></pre> <p>Updates the estimated time remaining label in the GUI.</p> <p>This method converts the estimated time remaining from seconds to a time format (hours, minutes, and seconds), updates the time remaining label, and schedules itself to be called again after 1 second if there is still time remaining.</p> <p>If the estimated time remaining is less than 0, it is set to 0. If there is still time remaining, and the function is already scheduled, the scheduled function is cancelled. Then, this function is scheduled to be called again after 1 second.</p> PARAMETER DESCRIPTION <code>estimated_time_remaining</code> <p>The estimated time remaining in seconds.</p> <p> TYPE: <code>float</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def update_estimated_time_remaining(self, estimated_time_remaining: float) -&gt; None:\n    \"\"\"\n    Updates the estimated time remaining label in the GUI.\n\n    This method converts the estimated time remaining from seconds to a time format (hours, minutes,\n    and seconds), updates the time remaining label, and schedules itself to be called again after 1 second if\n    there is still time remaining.\n\n    If the estimated time remaining is less than 0, it is set to 0. If there is still time remaining,\n    and the function is already scheduled, the scheduled function is cancelled. Then, this function is scheduled\n    to be called again after 1 second.\n\n    Parameters:\n        estimated_time_remaining (float): The estimated time remaining in seconds.\n\n    Returns:\n        None\n    \"\"\"\n    # If estimated_time_remaining is less than 0, set it to 0\n    estimated_time_remaining = max(estimated_time_remaining, 0)\n\n    # Convert the estimated time remaining to hours, minutes, and seconds\n    time_remaining = str(datetime.timedelta(seconds=int(estimated_time_remaining)))\n\n    # Update the time remaining label\n    self.time_remaining_label.configure(\n        text=f\"Estimated Time Remaining: {time_remaining}\"\n    )\n    self.update_idletasks()\n\n    # If there is still time remaining\n    if estimated_time_remaining &gt; 0:\n        # If the function is already scheduled, cancel it\n        if self.after_id is not None:\n            self.after_cancel(self.after_id)\n\n        # Schedule this function to be called again after 1 second and store the ID\n        self.after_id = self.after(\n            1000, self.update_estimated_time_remaining, estimated_time_remaining - 1\n        )\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.update_progress_and_status","title":"update_progress_and_status","text":"<pre><code>update_progress_and_status(status: str, program_progress: Optional[Union[float, None]] = None) -&gt; None\n</code></pre> <p>Updates the progress and status of the program.</p> <p>This method updates the global variables <code>progress</code> and <code>progress_status</code> that are used to track the progress and status of the program. If the <code>program_progress</code> parameter is provided and is different from the current <code>progress</code>, it updates the progress and status labels in the GUI.</p> PARAMETER DESCRIPTION <code>status</code> <p>The new status of the program. program_progress (float, optional): The new progress</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def update_progress_and_status(\n    self, status: str, program_progress: Optional[Union[float, None]] = None\n) -&gt; None:\n    \"\"\"\n    Updates the progress and status of the program.\n\n    This method updates the global variables `progress` and `progress_status` that are used to track the progress\n    and status of the program. If the `program_progress` parameter is provided and is different from the current\n    `progress`, it updates the progress and status labels in the GUI.\n\n    Parameters:\n        status (str): The new status of the program. program_progress (float, optional): The new progress\n        of the program. If not provided, the current global progress is used.\n\n    Returns:\n        None\n    \"\"\"\n    # Update the global variables that were updated in the AnilistMangaUpdater.py file\n    global progress, progress_status  # pylint: disable=W0603\n    if program_progress is None:\n        Logger.INFO(\"No program progress provided. Using global progress.\")\n        program_progress = progress\n    if program_progress != progress:\n        # If progress is different update objects associated with it\n        Logger.INFO(\n            \"AnilistMangaUpdater progress is different from global progress. Updating progress and status.\"\n        )\n        progress = program_progress\n        progress_status = status\n        self.percent_label.configure(text=f\"{round((progress * 100), 1)}%\")\n        self.progress_bar_tooltip.configure(\n            message=f\"{str(round((progress * 100), 1))}%\"\n        )\n        Logger.INFO(f\"Updated progress to: {progress} and status to: {status}\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.update_progress_bar","title":"update_progress_bar","text":"<pre><code>update_progress_bar() -&gt; None\n</code></pre> <p>Updates the progress bar, status label, and time taken label in the GUI.</p> <p>This method is scheduled to be called every 100 milliseconds. If the program thread is running, it updates the progress and status, as well as the time taken label. If the program thread is not running, it logs a warning and stops the function.</p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def update_progress_bar(self) -&gt; None:\n    \"\"\"\n    Updates the progress bar, status label, and time taken label in the GUI.\n\n    This method is scheduled to be called every 100 milliseconds. If the program thread is running,\n    it updates the progress and status, as well as the time taken label. If the program thread is not running,\n    it logs a warning and stops the function.\n\n    Parameters:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    if program_thread is not None and program_thread.is_alive():\n        # If the thread is running, update the progress and status\n        self.progress_bar.set(progress)\n        self.status_label.configure(text=f\"Status: {progress_status}\")\n\n        # Update the time taken\n        time_taken: float = time.time() - self.start_time\n        minutes, seconds = divmod(time_taken, 60)\n        hours, minutes = divmod(minutes, 60)\n        self.time_taken_label.configure(\n            text=f\"Time Taken: {int(hours):01d}:{int(minutes):02d}:{int(seconds):02d}\"\n        )\n        self.update_idletasks()\n    else:\n        # If the thread is not running, log a warning and stop the function\n        Logger.WARNING(\n            \"AnilistMangaUpdater thread is not running. Stopping progress bar update.\"\n        )\n        return\n    self.after(50, self.update_progress_bar)\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.App.update_terminal","title":"update_terminal","text":"<pre><code>update_terminal(text: str) -&gt; None\n</code></pre> <p>Updates the terminal in the GUI with the provided text.</p> <p>This method first checks if the scrollbar is at the bottom of the terminal. If it is, the method will automatically scroll to the end after inserting the text. The terminal is temporarily enabled for the insertion of the text and then disabled again to prevent manual edits.</p> PARAMETER DESCRIPTION <code>text</code> <p>The text to be inserted into the terminal.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def update_terminal(self, text: str) -&gt; None:\n    \"\"\"\n    Updates the terminal in the GUI with the provided text.\n\n    This method first checks if the scrollbar is at the bottom of the terminal. If it is, the method will\n    automatically scroll to the end after inserting the text. The terminal is temporarily enabled for the insertion\n    of the text and then disabled again to prevent manual edits.\n\n    Parameters:\n        text (str): The text to be inserted into the terminal.\n\n    Returns:\n        None\n    \"\"\"\n    # Check if the scrollbar is at the bottom\n    at_bottom = self.terminal.yview()[1] == 1.0\n\n    # Enable the terminal and insert the text\n    self.terminal.configure(state=\"normal\")\n    self.terminal.insert(\"end\", f\"\\n{text}\")\n\n    # If the scrollbar was at the bottom before inserting, scroll to the end\n    if at_bottom:\n        self.terminal.see(\"end\")\n\n    # Force Tkinter to update the GUI\n    self.terminal.update_idletasks()\n\n    # Disable the terminal\n    self.terminal.configure(state=\"disabled\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.add_alternative_title","title":"add_alternative_title","text":"<pre><code>add_alternative_title(alt_titles_dict) -&gt; None\n</code></pre> <p>Adds an alternative title to the alternative titles dictionary.</p> <p>This function prompts the user to input an original title and its corresponding alternative title. If the user provides valid inputs, it updates the alternative titles dictionary with the new pair and saves it to a file.</p> PARAMETER DESCRIPTION <code>alt_titles_dict</code> <p>The dictionary containing the original titles as keys and alternative titles as values.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def add_alternative_title(alt_titles_dict) -&gt; None:\n    \"\"\"\n    Adds an alternative title to the alternative titles dictionary.\n\n    This function prompts the user to input an original title and its corresponding alternative title.\n    If the user provides valid inputs, it updates the alternative titles dictionary with the new pair\n    and saves it to a file.\n\n    Parameters:\n        alt_titles_dict (dict): The dictionary containing the original titles as keys and alternative titles as values.\n\n    Returns:\n        None\n    \"\"\"\n    Logger.INFO(\"Prompting user for original title.\")\n    original_title = simpledialog.askstring(\n        \"Add Alternative Title\", \"Enter the original title:\"\n    )\n    if original_title is None or original_title == \"\":\n        Logger.WARNING(\"No original title provided. Exiting add.\")\n        return\n    Logger.INFO(f\"Original title provided: {original_title}\")\n    Logger.INFO(\"Prompting user for alternative title.\")\n    alternative_title = simpledialog.askstring(\n        \"Add Alternative Title\", \"Enter the alternative title:\"\n    )\n    if alternative_title is None or alternative_title == \"\":\n        Logger.WARNING(\"No alternative title provided. Exiting add.\")\n        return\n    Logger.INFO(f\"Alternative title provided: {alternative_title}\")\n    alt_titles_dict[original_title] = alternative_title\n    Save_Alt_Titles_To_File(alt_titles_dict)\n    Logger.INFO(\"Saved alternative titles to file.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.change_appearance_mode_event","title":"change_appearance_mode_event","text":"<pre><code>change_appearance_mode_event(new_appearance_mode: str) -&gt; None\n</code></pre> <p>Changes the appearance mode of the application.</p> <p>This function changes the appearance mode of the application based on the input parameter. It logs the new appearance mode and the successful change of the appearance mode.</p> PARAMETER DESCRIPTION <code>new_appearance_mode</code> <p>The new appearance mode to be set. This should be a string representing</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def change_appearance_mode_event(new_appearance_mode: str) -&gt; None:\n    \"\"\"\n    Changes the appearance mode of the application.\n\n    This function changes the appearance mode of the application based on the input parameter.\n    It logs the new appearance mode and the successful change of the appearance mode.\n\n    Parameters:\n        new_appearance_mode (str): The new appearance mode to be set. This should be a string representing\n        the desired appearance mode.\n\n    Returns:\n        None\n    \"\"\"\n    Logger.INFO(f\"Changing appearance mode to: {new_appearance_mode}\")\n    customtkinter.set_appearance_mode(new_appearance_mode)\n    Logger.INFO(\"Appearance mode changed successfully.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.change_scaling_event","title":"change_scaling_event","text":"<pre><code>change_scaling_event(new_scaling: str) -&gt; None\n</code></pre> <p>Changes the UI scaling of the application.</p> <p>This function changes the UI scaling of the application based on the input parameter. It logs the new UI scaling and the successful change of the UI scaling.</p> PARAMETER DESCRIPTION <code>new_scaling</code> <p>The new UI scaling to be set. This should be a string representing the desired UI</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def change_scaling_event(new_scaling: str) -&gt; None:\n    \"\"\"\n    Changes the UI scaling of the application.\n\n    This function changes the UI scaling of the application based on the input parameter.\n    It logs the new UI scaling and the successful change of the UI scaling.\n\n    Parameters:\n        new_scaling (str): The new UI scaling to be set. This should be a string representing the desired UI\n        scaling in percentage format (e.g., \"100%\").\n\n    Returns:\n        None\n    \"\"\"\n    Logger.INFO(f\"Changing UI scaling to: {new_scaling}\")\n    new_scaling_float = int(new_scaling.replace(\"%\", \"\")) / 100\n    customtkinter.set_widget_scaling(new_scaling_float)\n    Logger.INFO(\"UI scaling changed successfully.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.delete_alternative_title","title":"delete_alternative_title","text":"<pre><code>delete_alternative_title(alt_titles_dict, original_title) -&gt; None\n</code></pre> <p>Deletes an alternative title from the alternative titles dictionary.</p> <p>This function removes the alternative title associated with the given original title from the alternative titles dictionary and saves the updated dictionary to a file.</p> PARAMETER DESCRIPTION <code>alt_titles_dict</code> <p>The dictionary containing the original titles as keys and alternative titles as values.</p> <p> TYPE: <code>dict</code> </p> <code>original_title</code> <p>The original title for which the alternative title is to be deleted.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def delete_alternative_title(alt_titles_dict, original_title) -&gt; None:\n    \"\"\"\n    Deletes an alternative title from the alternative titles dictionary.\n\n    This function removes the alternative title associated with the given original title\n    from the alternative titles dictionary and saves the updated dictionary to a file.\n\n    Parameters:\n        alt_titles_dict (dict): The dictionary containing the original titles as keys and alternative titles as values.\n        original_title (str): The original title for which the alternative title is to be deleted.\n\n    Returns:\n        None\n    \"\"\"\n    Logger.INFO(f\"Deleting alternative title: {original_title}\")\n    alt_titles_dict.pop(original_title, None)\n    Save_Alt_Titles_To_File(alt_titles_dict)\n    Logger.INFO(\"Saved alternative titles to file.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.edit_alternative_title","title":"edit_alternative_title","text":"<pre><code>edit_alternative_title(alt_titles_dict, original_title) -&gt; None\n</code></pre> <p>Edits an alternative title in the alternative titles dictionary.</p> <p>This function prompts the user to input a new alternative title for a given original title. If the user provides a valid new alternative title, it updates the alternative titles dictionary and saves it to a file.</p> PARAMETER DESCRIPTION <code>alt_titles_dict</code> <p>The dictionary containing the original titles as keys and alternative titles as values.</p> <p> TYPE: <code>dict</code> </p> <code>original_title</code> <p>The original title for which the alternative title is to be edited.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def edit_alternative_title(alt_titles_dict, original_title) -&gt; None:\n    \"\"\"\n    Edits an alternative title in the alternative titles dictionary.\n\n    This function prompts the user to input a new alternative title for a given original title.\n    If the user provides a valid new alternative title, it updates the alternative titles dictionary\n    and saves it to a file.\n\n    Parameters:\n        alt_titles_dict (dict): The dictionary containing the original titles as keys and alternative titles as values.\n        original_title (str): The original title for which the alternative title is to be edited.\n\n    Returns:\n        None\n    \"\"\"\n    Logger.INFO(\"Prompting user for new alternative title.\")\n    new_alternative_title = simpledialog.askstring(\n        \"Edit Alternative Title\", \"Enter the new alternative title:\"\n    )\n    if new_alternative_title is None or new_alternative_title == \"\":\n        Logger.WARNING(\"No new alternative title provided. Exiting edit.\")\n        return\n    Logger.INFO(f\"New alternative title provided: {new_alternative_title}\")\n    alt_titles_dict[original_title] = new_alternative_title\n    Save_Alt_Titles_To_File(alt_titles_dict)\n    Logger.INFO(\"Saved alternative titles to file.\")\n</code></pre>"},{"location":"Main/GUI/#AnilistMangaUpdater.Main.GUI.on_close","title":"on_close","text":"<pre><code>on_close() -&gt; None\n</code></pre> <p>Handles the event when the application is closed.</p> <p>This function is triggered when the application is being closed. It logs the closing event and then terminates the application.</p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Main/GUI.py</code> <pre><code>def on_close() -&gt; None:\n    \"\"\"\n    Handles the event when the application is closed.\n\n    This function is triggered when the application is being closed. It logs the closing event and then terminates\n    the application.\n\n    Parameters:\n        None\n\n    Returns:\n        None\n    \"\"\"\n    # Log the application closing\n    Logger.INFO(\"Closing the application.\")\n\n    # Exit the application\n    sys.exit(0)\n</code></pre>"},{"location":"Main/Program/","title":"Program","text":""},{"location":"Main/Program/#AnilistMangaUpdater.Main.Program.Program","title":"Program","text":"<pre><code>Program(app: object)\n</code></pre> PARAMETER DESCRIPTION <code>app</code> <p>The gui object.</p> <p> TYPE: <code>object</code> </p> Source code in <code>AnilistMangaUpdater/Main/Program.py</code> <pre><code>def __init__(self, app: object) -&gt; None:  # pylint: disable=R0912, R0914, R0915\n    \"\"\"\n    Initializes the Program class. This goes through the entire process of the script.\n\n    Args:\n        app: The gui object.\n    \"\"\"\n    Logger.INFO(\"Initializing the class.\")\n    self.app = app\n    self.cache = Cache(\"Manga_Data/format_cache.json\")\n\n    Set_Chapters_Updated()\n    Logger.DEBUG(\"Set_Chapters_Updated called.\")\n\n    total_steps: int = 10  # Total number of steps in your program\n    current_step: float = 0  # Current step number\n\n    # Update progress and status\n    current_step += 0.5\n    app.update_progress_and_status(\n        \"Setting access token &amp; Loading configuration...\",\n        current_step / total_steps,\n    )\n    Logger.DEBUG(\"Updated progress and status.\")\n\n    # Set the access token\n    Set_Access_Token(app)\n    Logger.DEBUG(\"Set_Access_Token called.\")\n    # Check if the access token needs to be refreshed\n    refresh: Union[bool, None] = needs_refresh(app)\n    Logger.DEBUG(f\"needs_refresh returned: {refresh}\")\n    if refresh:\n        app.update_terminal(\"Access Token needs to be refreshed\")\n        app.update_progress_and_status(\"Token needs to be refreshed...\", 0)\n        Logger.WARNING(\n            \"Access token needs to be refreshed. Returning from __init__.\"\n        )\n        return\n\n    # Load the configuration from the config.json file\n    config: Union[dict, None] = load_config(\"config.json\")\n    Logger.DEBUG(f\"Loaded config: {config}\")\n    if config is None:\n        # If the configuration is not loaded successfully, get the configuration\n        Get_Config(app)\n        Logger.WARNING(\n            \"Config is None. Called Get_Config and returning from __init__.\"\n        )\n        return\n\n    # If the configuration is loaded successfully, get the client ID, secret ID,\n    # access token, months, and private from the configuration\n    client: str = config[\"ANILIST_CLIENT_ID\"]\n    secret: str = config[\"ANILIST_CLIENT_SECRET\"]\n    token: str = config[\"ACCESS_TOKEN\"]\n    months: str = config[\"MONTHS\"]\n    private: str = config[\"PRIVATE\"]\n\n    # Flag to indicate whether all values are set\n    all_values_set: bool = True\n\n    # Check if any of the values are None and print a message if they are\n    if client is None:\n        app.update_terminal(\"Client ID needs to be set\")\n        all_values_set = False\n        Logger.WARNING(\"Client ID is None.\")\n    if secret is None:\n        app.update_terminal(\"Secret ID needs to be set\")\n        all_values_set = False\n        Logger.WARNING(\"Secret ID is None.\")\n    if months is None:\n        app.update_terminal(\"Months needs to be set\")\n        all_values_set = False\n        Logger.WARNING(\"Months is None.\")\n    if private is None:\n        app.update_terminal(\"Private needs to be set\")\n        all_values_set = False\n        Logger.WARNING(\"Private is None.\")\n    if token is None:\n        app.update_terminal(\"Access Token needs to be set\")\n        all_values_set = False\n        Logger.WARNING(\"Access Token is None.\")\n\n    # If not all values are set, return\n    if not all_values_set:\n        app.update_progress_and_status(\"Configuration needs to be set...\", 0)\n        Logger.WARNING(\"Not all values are set. Returning from __init__.\")\n        return\n\n    # Update progress and status\n    current_step += 0.5\n    app.update_progress_and_status(\n        \"Checking file path...\", current_step / total_steps\n    )\n    Logger.INFO(\"Checking file path...\")\n\n    # Check if the file path is set\n    if app.file_path == \"\":\n        app.update_terminal(\n            \"Error: Please browse for a kenmei export file. (Previous is Optional)\"\n        )\n        Logger.ERROR(\"File path not set.\")\n        return\n\n    # Update progress and status\n    current_step += 0.5\n    app.update_progress_and_status(\n        \"Getting manga from CSV...\", current_step / total_steps\n    )\n    Logger.INFO(\"Getting manga from CSV...\")\n\n    # Get the manga found in the CSV file\n    Manga_Found_In_CSV(app)\n    Logger.INFO(\"Manga found in CSV.\")\n\n    # Record the start time\n    manga_data_start_time: float = time.time()\n    Logger.DEBUG(f\"Start time for manga data: {manga_data_start_time}\")\n\n    # Update progress and status\n    current_step += 0.5\n    app.update_progress_and_status(\n        \"Getting manga IDs...\", current_step / total_steps\n    )\n    Logger.INFO(\"Getting manga IDs...\")\n\n    # Call the function and get the list of IDs &amp; Names\n    manga_names_ids: dict = {}\n    manga_names: dict = Get_Manga_Names(app, alternative_titles_dict)\n    Logger.DEBUG(f\"Manga names: {manga_names}\")\n\n    # Before the loop, record the start time and initialize a list to store the times\n    start_time: float = time.time()\n    times: list = []\n    Logger.DEBUG(f\"Start time for loop: {start_time}\")\n\n    # Initialize a counter for the number of manga processed\n    manga_processed: int = 0\n\n    # Iterate through the manga_names dictionary\n    manga_name: str\n    for manga_name, manga_info in manga_names.items():\n        progress: float\n        Logger.INFO(f\"Processing manga: {manga_name}\")\n        try:\n            # noinspection PyUnboundLocalVariable\n            app.update_progress_and_status(\n                f\"Getting ID for {manga_name}...\",\n                progress,  # pylint: disable=E0601  # noqa: F821\n            )\n            Logger.DEBUG(\"Updated progress and status.\")\n        except UnboundLocalError:\n            app.update_progress_and_status(f\"Getting ID for {manga_name}...\")\n            Logger.ERROR(\"UnboundLocalError occurred. Updated progress and status.\")\n        app.update_idletasks()\n        Logger.DEBUG(\"Updated idle tasks.\")\n\n        # Record the time before finding the ID\n        time_before: float = time.time()\n        Logger.DEBUG(f\"Time before finding ID: {time_before}\")\n\n        # Replace all occurrences of U+2019 with U+0060 in manga_name\n        manga_name = manga_name.replace(\"\\u2019\", \"\\u0060\")\n        manga_name = manga_name.replace(\"-\", \" \")\n        manga_name = manga_name.replace(\"`\", \"'\")\n        Logger.DEBUG(f\"Processed manga name: {manga_name}\")\n\n        status: str = manga_info[\"status\"]\n        Logger.DEBUG(f\"Manga status: {status}\")\n\n        # Get the manga IDs regardless of the status\n        if status != \"plan_to_read\":\n            if \"last_chapter_read\" in manga_info:\n                last_chapter_read = manga_info[\"last_chapter_read\"]\n                manga_search = MangaSearch(manga_name, last_chapter_read, app)\n                Logger.DEBUG(\"Created MangaSearch instance with last chapter read.\")\n            else:\n                manga_search = MangaSearch(manga_name, None, app)\n                Logger.DEBUG(\n                    \"Created MangaSearch instance without last chapter read.\"\n                )\n        else:\n            manga_search = MangaSearch(manga_name, None, app)\n            Logger.DEBUG(\"Created MangaSearch instance without last chapter read.\")\n\n        manga_ids: list = manga_search.get_manga_id()\n        Logger.DEBUG(f\"Got manga IDs: {manga_ids}\")\n\n        for manga_id in manga_ids:\n            # Check if the media format is in the cache\n            media_info: Union[str, None] = self.cache.get(f\"{manga_id}_format\")\n            if media_info is None:\n                # Get the format of the manga regardless of the status\n                media_info = Get_Format(manga_id, app)\n                Logger.DEBUG(f\"Got media info: {media_info}\")\n                # Add the media format to the cache\n                self.cache.set(f\"{manga_id}_format\", media_info)\n\n            # If the format of the manga is not a novel\n            if media_info != \"NOVEL\":\n                Logger.DEBUG(\"Media info is not a novel.\")\n\n                # If the manga name is not already in the manga_names_ids dictionary\n                if manga_name not in manga_names_ids:\n                    # Add the manga name to the manga_names_ids dictionary\n                    manga_names_ids[manga_name] = []\n                    Logger.DEBUG(\"Added manga name to manga_names_ids.\")\n\n                # If the status is not 'plan_to_read', append additional information\n                if status != \"plan_to_read\":\n                    if \"last_chapter_read\" in manga_info:\n                        last_chapter_read = manga_info[\"last_chapter_read\"]\n                        last_read_at = manga_info[\"last_read_at\"]\n                        manga_names_ids[manga_name].append(\n                            (\n                                manga_id,\n                                last_chapter_read,\n                                manga_info[\"status\"],\n                                last_read_at,\n                            )\n                        )\n                    else:\n                        manga_names_ids[manga_name].append(\n                            (manga_id, None, manga_info[\"status\"], None)\n                        )\n                    Logger.DEBUG(\n                        \"Appended additional information to manga_names_ids.\"\n                    )\n        # Increment the counter for the number of manga processed\n        manga_processed += 1\n\n        # Record the time after finding the ID\n        time_after = time.time()\n        Logger.DEBUG(f\"Time after finding ID: {time_after}\")\n\n        operation_time: float = time_after - time_before\n        Logger.DEBUG(f\"Operation time: {operation_time}\")\n\n        # Append the operation time to the list\n        times.append(operation_time)\n        Logger.DEBUG(\"Appended operation time to times.\")\n\n        # Calculate the average time per ID and the estimated total time\n        average_time = sum(times) / len(times)\n        estimated_total_time = average_time * len(manga_names)\n        Logger.INFO(\n            f\"Average time: {average_time}, Estimated total time: {estimated_total_time}\"\n        )\n\n        # Calculate the estimated time remaining\n        time_elapsed: float = time.time() - start_time\n        estimated_time_remaining = estimated_total_time - time_elapsed\n        Logger.INFO(\n            f\"Time elapsed: {time_elapsed}, \"\n            f\"Estimated time remaining: {estimated_time_remaining}\"\n        )\n\n        # Print the estimated time remaining\n        app.update_estimated_time_remaining(estimated_time_remaining)\n        Logger.DEBUG(\"Updated estimated time remaining.\")\n\n        # Calculate the progress for this step based on the number of manga processed\n        step_progress = manga_processed / len(manga_names)\n        Logger.DEBUG(f\"Step progress: {step_progress}\")\n\n        # Adjust the progress to be between 20% and 50%\n        progress = 0.2 + step_progress * 0.3\n        Logger.DEBUG(f\"Adjusted progress: {progress}\")\n\n    # After the loop, the progress should be around 50%\n    app.update_progress_and_status(\"Finished getting IDs!\")\n    Logger.INFO(\"Finished getting IDs!\")\n\n    # Update progress and status\n    current_step += 3.5\n    app.update_progress_and_status(\n        \"Cleaning manga IDs...\", current_step / total_steps\n    )\n    Logger.INFO(\"Cleaning manga IDs...\")\n\n    # Clean the manga_names_ids dictionary\n    manga_names_ids = Clean_Manga_IDs(manga_names_ids, app)\n    Logger.DEBUG(\"Cleaned manga_names_ids.\")\n\n    # Print the dictionary containing manga names and associated IDs\n    self.app.update_terminal(\"\\nManga Names With Associated IDs &amp; Chapters Read:\")\n\n    with ThreadPoolExecutor(max_workers=1) as executor:\n        # Create a list to store the futures\n        futures: list = []\n\n        for manga_name, ids in manga_names_ids.items():\n            for id_info in ids:\n                # Submit the task to the executor\n                future = executor.submit(\n                    Program.process_id_info, manga_name, id_info\n                )\n                futures.append(future)\n\n        # Gather the results\n        messages: list = []\n        for future in futures:\n            messages.append(future.result())\n\n        # Update the terminal\n        self.app.update_terminal(\"\\n\".join(messages))\n    self.app.update_terminal(\"\\n\\n\")\n\n    app.update_progress_and_status(\n        \"Writing no manga found file...\",\n        (current_step + (0.5 / 3) * 2) / total_steps,\n    )\n    Logger.INFO(\"Writing no manga found file...\")\n    Get_No_Manga_Found(app)\n\n    # Calculate and print the time taken\n    manga_data_time_taken: float = self.print_time_taken(\n        manga_data_start_time, \"get Manga data\"\n    )\n    Logger.INFO(f\"Time taken to get manga data: {manga_data_time_taken}\")\n    self.app.update_terminal(\"\")\n\n    # Record the start time\n    manga_update_start_time = time.time()\n    Logger.DEBUG(f\"Start time for manga update: {manga_update_start_time}\")\n\n    # Update progress and status\n    current_step = 6\n    app.update_progress_and_status(\"Updating manga...\", 0.6)\n    Logger.INFO(\"Updating manga...\")\n\n    # Before the loop, initialize a counter for the number of manga updated\n    manga_updated: int = 0\n    total_manga: int = sum(len(info_list) for info_list in manga_names_ids.values())\n    Logger.INFO(f\"Total manga to update: {total_manga}\")\n\n    # Create a list to store the IDs of the manga that were not updated\n    skipped_ids: list = []\n    Logger.DEBUG(\"Created list for skipped IDs.\")\n\n    # Get the entire manga list from AniList\n    manga_list: list[dict[str, Union[int, str]]] = Get_User_Manga_List(app)\n    Logger.INFO(\"Got user manga list from AniList.\")\n\n    # Iterate over entries in the cleaned manga_names_ids dictionary\n    for manga_name, manga_info_list in manga_names_ids.items():\n        Logger.INFO(f\"Processing manga: {manga_name}\")\n        # For each manga, there is a list of information (manga_info_list)\n        for manga_info in manga_info_list:\n            # Unpack the manga_info list into individual variables\n            manga_id, last_chapter_read, status, last_read_at = manga_info\n            Logger.DEBUG(f\"Processing manga info: {manga_info}\")\n            # Find the manga in the manga list\n            manga_entry: Union[dict[str, Union[int, str]], None] = next(\n                (entry for entry in manga_list if entry[\"mediaId\"] == manga_id),\n                None,\n            )\n            # If the manga was not found in the manga list\n            if manga_entry is None:\n                self.app.update_terminal(\n                    f\"Manga: {manga_name} (ID: {manga_id}) was not \"\n                    \"found on user list. Adding...\"\n                )\n\n                Logger.WARNING(\n                    f\"Manga: {manga_name} \"\n                    f\"(ID: {manga_id}) was not found \"\n                    \"on user list. Adding...\"\n                )\n                chapter_anilist, status_anilist = 0, None\n            else:\n                # Get the current progress and status of the manga from the manga entry\n                chapter_anilist, status_anilist = (\n                    (\n                        int(manga_entry[\"progress\"])\n                        if isinstance(manga_entry[\"progress\"], str)\n                        else manga_entry[\"progress\"]\n                    ),\n                    manga_entry[\"status\"],\n                )\n                Logger.DEBUG(\n                    f\"Got current progress and status from manga entry: {manga_entry}\"\n                )\n\n            # If the progress or status has changed or the manga was not found in the manga list\n\n            if (\n                manga_entry is None\n                or chapter_anilist != last_chapter_read\n                or status_anilist != status\n            ):\n                Logger.INFO(f\"Updating manga: {manga_name}\")\n                manga = Manga(\n                    name=manga_name,\n                    manga_id=manga_id,\n                    last_chapter_read=last_chapter_read,\n                    private_bool=private,\n                    status=status,\n                    last_read_at=last_read_at,\n                    months=months,\n                )\n                Logger.DEBUG(f\"Created Manga instance: {manga}\")\n\n                Update_Manga(manga, app, chapter_anilist, status_anilist)\n                Logger.DEBUG(\"Updated manga.\")\n\n                # After updating the manga, increment the counter\n                manga_updated += 1\n                Logger.DEBUG(f\"Incremented manga_updated to: {manga_updated}\")\n\n                # Calculate the progress for this step\n                step_progress = manga_updated / total_manga\n                Logger.DEBUG(f\"Calculated step progress: {step_progress}\")\n\n                # Adjust the progress to be between 60% and 90%\n                progress = 0.6 + step_progress * 0.3\n                Logger.DEBUG(f\"Adjusted progress to: {progress}\")\n\n                app.update_progress_and_status(\n                    f\"Updating {manga_name}...\", progress\n                )\n                Logger.INFO(\"Updated progress and status.\")\n            else:\n                # If the progress and status have not changed, add the manga ID to list\n                skipped_ids.append(manga_id)\n                Logger.DEBUG(f\"Added manga ID: {manga_id} to skipped_ids.\")\n\n    # After the loop, print the IDs of the manga that were not updated\n    if skipped_ids:\n        Logger.WARNING(\n            f\"Skipped updating the following manga IDs because their entries \"\n            f\"did not change: {', '.join(map(str, skipped_ids))}\"\n        )\n        self.app.update_terminal(\n            f\"Skipped updating the following manga IDs because their entries \"\n            f\"did not change: {', '.join(map(str, skipped_ids))}\"\n        )\n        Logger.DEBUG(f\"Skipped IDs: {skipped_ids}\")\n\n    current_step += 3\n    Logger.INFO(\"Finished updating manga!\")\n    # After the loop, the progress should be exactly 90%\n    app.update_progress_and_status(\n        \"Finished updating manga!\", current_step / total_steps\n    )\n\n    # Update progress and status\n    current_step += 0.5\n    Logger.INFO(\"Writing chapters updated...\")\n    app.update_progress_and_status(\n        \"Writing chapters updated...\", current_step / total_steps\n    )\n\n    # Get the number of chapters updated\n    chapters_updated = Get_Chapters_Updated()\n    Logger.INFO(f\"\\nTotal chapters updated: {chapters_updated}\")\n    self.app.update_terminal(f\"\\nTotal chapters updated: {chapters_updated}\")\n    # Write the number of chapters updated to a file\n    write_chapters_updated_to_file(\"chapters_updated\", chapters_updated)\n\n    time.sleep(0.3)\n\n    # Script has finished, update progress and status\n    current_step += 0.5\n    Logger.INFO(\"Script Finished...\")\n    app.update_progress_and_status(\"Script Finished...\", current_step / total_steps)\n\n    time.sleep(0.3)\n\n    # Calculate and print the time taken\n    manga_update_time_taken = self.print_time_taken(\n        manga_update_start_time, \"update Manga data\"\n    )\n    Logger.INFO(\n        f\"Time taken to update Manga data: {manga_update_time_taken} seconds\"\n    )\n\n    # Calculate the total time taken by adding the time taken to get manga data\n    # and the time taken to update manga data\n    total_time = round((manga_data_time_taken + manga_update_time_taken), 3)\n    Logger.INFO(f\"\\nTotal time taken: {total_time} seconds\")\n    self.app.update_terminal(f\"\\nTotal time taken: {total_time} seconds\")\n\n    # Print a message indicating that the script has finished and provide\n    # information about the generated text files\n    Logger.INFO(\n        \"\\nScript has finished, the 2 txt files generated by the program have manga \"\n        \"that was not found on anilist and manga that had multiple id's associated to it.\"\n        \"\\nPlease check the 2 files to see if there is anything that you need to do manually.\\n\"\n    )\n    self.app.update_terminal(\n        \"\\nScript has finished, the 2 txt files generated by the program have manga \"\n        \"that was not found on anilist and manga that had multiple id's associated to it.\"\n        \"\\nPlease check the 2 files to see if there is anything that you need to do manually.\\n\"\n    )\n</code></pre>"},{"location":"Main/Program/#AnilistMangaUpdater.Main.Program.Program.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app = app\n</code></pre>"},{"location":"Main/Program/#AnilistMangaUpdater.Main.Program.Program.cache","title":"cache  <code>instance-attribute</code>","text":"<pre><code>cache = Cache('Manga_Data/format_cache.json')\n</code></pre>"},{"location":"Main/Program/#AnilistMangaUpdater.Main.Program.Program.print_time_taken","title":"print_time_taken","text":"<pre><code>print_time_taken(start_time: float, task_name: str) -&gt; float\n</code></pre> <p>Prints the time taken to perform a task and returns the time taken.</p> <p>This function calculates the time taken to perform a task. It then updates the terminal with a message indicating the time taken to perform the task.</p> PARAMETER DESCRIPTION <code>start_time</code> <p>The time when the task started.</p> <p> TYPE: <code>float</code> </p> <code>task_name</code> <p>The name of the task.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>float</code> <p>The time taken to perform the task, rounded to three decimal places.</p> <p> TYPE: <code>float</code> </p> Source code in <code>AnilistMangaUpdater/Main/Program.py</code> <pre><code>def print_time_taken(self, start_time: float, task_name: str) -&gt; float:\n    \"\"\"\n    Prints the time taken to perform a task and returns the time taken.\n\n    This function calculates the time taken to perform a task.\n    It then updates the terminal with a message indicating the time taken to perform the task.\n\n    Args:\n        start_time: The time when the task started.\n        task_name: The name of the task.\n\n    Returns:\n        float: The time taken to perform the task, rounded to three decimal places.\n    \"\"\"\n    Logger.DEBUG(\"Function print_time_taken called.\")\n    end_time: float = time.time()\n    Logger.DEBUG(f\"End time: {end_time}\")\n    time_taken: float = round((end_time - start_time), 3)\n    Logger.INFO(f\"Time taken to {task_name}: {time_taken} seconds\")\n    self.app.update_terminal(f\"\\nTime taken to {task_name}: {time_taken} seconds\")\n    Logger.DEBUG(\"Updated terminal with time taken.\")\n    return time_taken\n</code></pre>"},{"location":"Main/Program/#AnilistMangaUpdater.Main.Program.Program.process_id_info","title":"process_id_info  <code>staticmethod</code>","text":"<pre><code>process_id_info(manga_name: str, id_info: tuple) -&gt; str\n</code></pre> <p>Process the ID information of a manga.</p> PARAMETER DESCRIPTION <code>manga_name</code> <p>The name of the manga.</p> <p> TYPE: <code>str</code> </p> <code>id_info</code> <p>A tuple containing the manga ID, last chapter read, status, and last read date.</p> <p> TYPE: <code>tuple</code> </p> RETURNS DESCRIPTION <code>str</code> <p>A formatted string containing the processed information.</p> <p> TYPE: <code>str</code> </p> Source code in <code>AnilistMangaUpdater/Main/Program.py</code> <pre><code>@staticmethod\ndef process_id_info(manga_name: str, id_info: tuple) -&gt; str:\n    \"\"\"\n    Process the ID information of a manga.\n\n    Args:\n        manga_name (str): The name of the manga.\n        id_info (tuple): A tuple containing the manga ID, last chapter read,\n         status, and last read date.\n\n    Returns:\n        str: A formatted string containing the processed information.\n    \"\"\"\n    manga_id, last_chapter_read, status, last_read_at = id_info\n    message = (\n        f\"{manga_name}, ID: {manga_id}, Last Chapter Read: \"\n        f\"{last_chapter_read}, Status: {status}, Last Read At: {last_read_at}\"\n    )\n    Logger.DEBUG(f\"Processed info for manga: {manga_name}\")\n    return message\n</code></pre>"},{"location":"Manga/GetID/","title":"GetID","text":"<p>This module is responsible for handling all operations related to MangaSearch.</p> <p>It includes classes and methods to search for a manga on Anilist, process the search results, retrieve the ID of the manga, and handle any errors that occur during these operations.</p> CLASS DESCRIPTION <code>MangaSearch</code> <p>Represents a search for a manga on Anilist.</p> FUNCTION DESCRIPTION <code>process_title</code> <p>Processes the title by replacing certain characters.</p> <code>handle_server_error</code> <p>Handles server errors.</p>"},{"location":"Manga/GetID/#AnilistMangaUpdater.Manga.GetID.Clean_Manga_IDs","title":"Clean_Manga_IDs","text":"<pre><code>Clean_Manga_IDs(manga_names_ids: dict, app: object) -&gt; dict\n</code></pre> <p>Cleans the manga IDs by removing duplicates and separating manga with multiple unique IDs.</p> PARAMETER DESCRIPTION <code>manga_names_ids</code> <p>A dictionary mapping manga names to lists of IDs.</p> <p> TYPE: <code>dict</code> </p> <code>app</code> <p>The application object used to update the terminal and progress.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>A dictionary mapping manga names to lists of unique IDs.</p> <p> TYPE: <code>dict</code> </p> <code>dict</code> <p>Manga with multiple unique IDs are not included.</p> Source code in <code>AnilistMangaUpdater/Manga/GetID.py</code> <pre><code>def Clean_Manga_IDs(manga_names_ids: dict, app: object) -&gt; dict:\n    \"\"\"\n    Cleans the manga IDs by removing duplicates and separating manga with multiple unique IDs.\n\n    Parameters:\n        manga_names_ids (dict): A dictionary mapping manga names to lists of IDs.\n        app: The application object used to update the terminal and progress.\n\n    Returns:\n        dict: A dictionary mapping manga names to lists of unique IDs.\n        Manga with multiple unique IDs are not included.\n    \"\"\"\n    Logger.INFO(\"Function Clean_Manga_IDs called.\")\n    # Initialize dictionaries to store cleaned manga names and IDs, manga names with multiple IDs\n    cleaned_manga_names_ids = {}\n    multiple_id_manga_names = {}\n\n    # Iterate through manga names and their IDs\n    for manga_name, id_list in manga_names_ids.items():\n        Logger.DEBUG(f\"Processing manga: {manga_name}.\")\n        # Remove duplicates within the same manga name\n        unique_ids = list(set(id_list))\n        Logger.DEBUG(f\"Unique IDs for {manga_name}: {unique_ids}.\")\n\n        # Check if there are multiple unique IDs\n        if len(unique_ids) &gt; 1:\n            # If there are multiple unique IDs, add the manga name and IDs to the dictionary\n            multiple_id_manga_names[manga_name] = unique_ids\n            Logger.DEBUG(f\"Added {manga_name} to the list of manga with multiple IDs.\")\n        else:\n            # If only one ID, add it directly to the cleaned dictionary\n            cleaned_manga_names_ids[manga_name] = unique_ids\n            Logger.DEBUG(f\"Added {manga_name} to the cleaned list of manga.\")\n\n    # Print the manga names with multiple IDs\n    app.update_terminal(\"\\nDuplicate Manga Names and IDs:\")\n    Logger.INFO(\"Printing manga names with multiple IDs.\")\n    if not multiple_id_manga_names:\n        app.update_terminal(\"No Manga Names with Multiple IDs Found\\n\")\n        Logger.INFO(\"No manga names with multiple IDs found.\")\n    else:\n        for manga_name, ids in multiple_id_manga_names.items():\n            app.update_terminal(f\"\\n{manga_name}\")\n            for id_info in ids:\n                manga_id, last_chapter_read, status, last_read_at = id_info\n                message = (\n                    f\"ID: {manga_id}, \"\n                    f\"Last Chapter Read: {last_chapter_read}, \"\n                    f\"Status: {status}, \"\n                    f\"Last Read At: {last_read_at}\"\n                )\n                app.update_terminal(message)\n                Logger.DEBUG(f\"Printed ID info for {manga_name}: {message}.\")\n        app.update_terminal(\"\\n\")\n    # Write the manga names with multiple IDs to a file\n    app.update_progress_and_status(\n        \"Writing multiple ID's file...\", ((5.5 + (0.5 / 3)) / 10)\n    )\n    Logger.INFO(\"Writing multiple ID's file.\")\n    write_to_file(\"multiple_ids\", multiple_id_manga_names, formatter_multiple_ids)\n    # Return the cleaned manga names and IDs\n    Logger.INFO(\"Returning cleaned manga names and IDs.\")\n    return cleaned_manga_names_ids\n</code></pre>"},{"location":"Manga/GetID/#AnilistMangaUpdater.Manga.GetID.Get_No_Manga_Found","title":"Get_No_Manga_Found","text":"<pre><code>Get_No_Manga_Found(app: object) -&gt; None\n</code></pre> <p>Retrieves and prints the list of manga not found.</p> <p>This function writes the list of manga not found to a file and prints them to the terminal.</p> PARAMETER DESCRIPTION <code>app</code> <p>The application object used to update the terminal.</p> <p> TYPE: <code>object</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Manga/GetID.py</code> <pre><code>def Get_No_Manga_Found(app: object) -&gt; None:\n    \"\"\"\n    Retrieves and prints the list of manga not found.\n\n    This function writes the list of manga not found to a file and prints them to the terminal.\n\n    Parameters:\n        app: The application object used to update the terminal.\n\n    Returns:\n        None\n    \"\"\"\n    Logger.INFO(\"Function Get_No_Manga_Found called.\")\n    no_manga_found: list[tuple[str, Union[int, None]]] = return_no_manga_found()\n    # Write the manga not found to a file\n    write_to_file(\"not_found\", no_manga_found, formatter_not_found)\n    Logger.DEBUG(\"Wrote the list of manga not found to a file.\")\n    # Print the manga not found\n    app.update_terminal(\"\\nNot Found Manga:\")\n    Logger.INFO(\"Printing the list of manga not found.\")\n    if not no_manga_found:\n        app.update_terminal(\"No Manga Not Found\\n\")\n        Logger.INFO(\"No manga not found.\")\n    else:\n        for manga in no_manga_found:\n            name, last_chapter_read = manga\n            app.update_terminal(\n                f\"{name}, Last Chapter Read: {last_chapter_read}, Status: Not Found\"\n            )\n            Logger.DEBUG(f\"Printed info for manga not found: {name}.\")\n        app.update_terminal(\"\\n\")\n</code></pre>"},{"location":"Manga/MangaSearch/","title":"MangaSearch","text":"<p>This module contains the MangaSearch class which is used to search for a manga on Anilist.</p>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.no_manga_found","title":"no_manga_found  <code>module-attribute</code>","text":"<pre><code>no_manga_found: list[tuple[str, Union[int, None]]] = []\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch","title":"MangaSearch","text":"<pre><code>MangaSearch(name: str, last_chapter_read: Union[int, None], app: object, max_retries: int = 3, delay: float = 60)\n</code></pre> <p>A class used to search for a manga on Anilist.</p> ATTRIBUTE DESCRIPTION <code>name</code> <p>The name of the manga to search for.</p> <p> TYPE: <code>str</code> </p> <code>last_chapter_read</code> <p>The last chapter read of the manga.</p> <p> TYPE: <code>int</code> </p> <code>app</code> <p>The application object used to update the terminal and progress.</p> <p> TYPE: <code>object</code> </p> <code>max_retries</code> <p>The maximum number of retries. Defaults to 5.</p> <p> TYPE: <code>int</code> </p> <code>delay</code> <p>The delay between retries in seconds. Defaults to 15.</p> <p> TYPE: <code>int</code> </p> <code>retry_count</code> <p>The current number of retries.</p> <p> TYPE: <code>int</code> </p> <code>matches</code> <p>The list of matches from the search results.</p> <p> TYPE: <code>list</code> </p> <code>id_list</code> <p>The list of IDs for the matches.</p> <p> TYPE: <code>list</code> </p> METHOD DESCRIPTION <code>search_manga</code> <p>Searches for the manga on Anilist.</p> <code>process_manga_item</code> <p>Processes a manga item from the search results.</p> <code>process_title</code> <p>Processes the title by replacing certain characters.</p> <code>check_title_match</code> <p>Checks if the title matches the name.</p> <code>get_id_list</code> <p>Gets the list of IDs from the matches.</p> <code>print_details</code> <p>Prints the details of the matches.</p> <code>handle_no_ids_found</code> <p>Handles the case where no IDs are found.</p> <code>handle_server_error</code> <p>Handles server errors.</p> <code>get_manga_id</code> <p>Retrieves the ID of the manga.</p> PARAMETER DESCRIPTION <code>name</code> <p>The name of the manga to search for.</p> <p> TYPE: <code>str</code> </p> <code>last_chapter_read</code> <p>The last chapter read of the manga.</p> <p> TYPE: <code>int</code> </p> <code>app</code> <p>The application object used to update the terminal and progress.</p> <p> TYPE: <code>object</code> </p> <code>max_retries</code> <p>The maximum number of retries. Defaults to 5.</p> <p> TYPE: <code>int</code> DEFAULT: <code>3</code> </p> <code>delay</code> <p>The delay between retries in seconds. Defaults to 15.</p> <p> TYPE: <code>float</code> DEFAULT: <code>60</code> </p> <code>retry_count</code> <p>The current number of retries.</p> <p> TYPE: <code>int</code> </p> <code>matches</code> <p>The list of matches from the search results.</p> <p> TYPE: <code>list</code> </p> <code>id_list</code> <p>The list of IDs for the matches.</p> <p> TYPE: <code>list</code> </p> <code>cache</code> <p>The cache object used to store the manga data.</p> <p> </p> Source code in <code>AnilistMangaUpdater/Manga/manga_search.py</code> <pre><code>def __init__(  # pylint: disable=R0913\n    self,\n    name: str,\n    last_chapter_read: Union[int, None],\n    app: object,\n    max_retries: int = 3,\n    delay: float = 60,\n) -&gt; None:\n    \"\"\"\n    Initializes the MangaSearch object.\n\n    Parameters:\n        name (str): The name of the manga to search for.\n        last_chapter_read (int): The last chapter read of the manga.\n        app: The application object used to update the terminal and progress.\n        max_retries (int, optional): The maximum number of retries. Defaults to 5.\n        delay (float, optional): The delay between retries in seconds. Defaults to 15.\n        retry_count (int): The current number of retries.\n        matches (list): The list of matches from the search results.\n        id_list (list): The list of IDs for the matches.\n        cache: The cache object used to store the manga data.\n    \"\"\"\n    Logger.INFO(\"Function __init__ called.\")\n    Logger.DEBUG(\n        f\"Parameters - name: {name}, \"\n        f\"last_chapter_read: {last_chapter_read}, \"\n        f\"max_retries: {max_retries}, \"\n        f\"delay: {delay}\"\n    )\n    self.name: str = name\n    self.last_chapter_read: Union[int, None] = last_chapter_read\n    self.app: object = app\n    self.max_retries: int = max_retries\n    self.delay: float = delay\n    self.retry_count: int = 0\n    self.matches: list = []\n    self.id_list: list = []\n    self.cache = Cache(\"Manga_Data/title_cache.json\")\n    Logger.DEBUG(\"MangaSearch object initialized.\")\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.app","title":"app  <code>instance-attribute</code>","text":"<pre><code>app: object = app\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.cache","title":"cache  <code>instance-attribute</code>","text":"<pre><code>cache = Cache('Manga_Data/title_cache.json')\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.delay","title":"delay  <code>instance-attribute</code>","text":"<pre><code>delay: float = delay\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.id_list","title":"id_list  <code>instance-attribute</code>","text":"<pre><code>id_list: list = []\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.last_chapter_read","title":"last_chapter_read  <code>instance-attribute</code>","text":"<pre><code>last_chapter_read: Union[int, None] = last_chapter_read\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.matches","title":"matches  <code>instance-attribute</code>","text":"<pre><code>matches: list = []\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.max_retries","title":"max_retries  <code>instance-attribute</code>","text":"<pre><code>max_retries: int = max_retries\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.name","title":"name  <code>instance-attribute</code>","text":"<pre><code>name: str = name\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.retry_count","title":"retry_count  <code>instance-attribute</code>","text":"<pre><code>retry_count: int = 0\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.check_title_match","title":"check_title_match","text":"<pre><code>check_title_match(title: str) -&gt; bool\n</code></pre> <p>Checks if the title matches the name.</p> PARAMETER DESCRIPTION <code>title</code> <p>The title to check.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if the title matches the name, False otherwise.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>AnilistMangaUpdater/Manga/manga_search.py</code> <pre><code>def check_title_match(self, title: str) -&gt; bool:\n    \"\"\"\n    Checks if the title matches the name.\n\n    Parameters:\n        title (str): The title to check.\n\n    Returns:\n        bool: True if the title matches the name, False otherwise.\n    \"\"\"\n    Logger.INFO(\"Function check_title_match called.\")\n    Logger.DEBUG(f\"Checking if title: {title} matches name: {self.name}\")\n    match = Check_Title_Match(title, self.name)\n    Logger.DEBUG(f\"Match result: {match}\")\n    return match\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.get_id_list","title":"get_id_list","text":"<pre><code>get_id_list() -&gt; None\n</code></pre> <p>Gets the list of IDs from the matches.</p> <p>This method sorts the matches by the match score in descending order. Then it gets the list of IDs for the matches with a positive match score.</p> Source code in <code>AnilistMangaUpdater/Manga/manga_search.py</code> <pre><code>def get_id_list(self) -&gt; None:\n    \"\"\"\n    Gets the list of IDs from the matches.\n\n    This method sorts the matches by the match score in descending order.\n    Then it gets the list of IDs for the matches with a positive match score.\n    \"\"\"\n    Logger.INFO(\"Function get_id_list called.\")\n    self.matches.sort(key=lambda x: x[0], reverse=True)\n    Logger.DEBUG(\"Sorted matches by match score in descending order.\")\n    self.id_list = [manga_item[\"id\"] for match, manga_item in self.matches if match]\n    Logger.DEBUG(f\"Got list of IDs from matches: {self.id_list}\")\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.get_manga_id","title":"get_manga_id","text":"<pre><code>get_manga_id() -&gt; list[int]\n</code></pre> <p>Gets the ID of the manga.</p> RETURNS DESCRIPTION <code>list</code> <p>A list of manga IDs.</p> <p> TYPE: <code>list[int]</code> </p> Source code in <code>AnilistMangaUpdater/Manga/manga_search.py</code> <pre><code>def get_manga_id(self) -&gt; list[int]:\n    \"\"\"\n    Gets the ID of the manga.\n\n    Returns:\n        list: A list of manga IDs.\n    \"\"\"\n    Logger.INFO(\"Function get_manga_id called.\")\n    result: list = []\n\n    # Check if the manga ID is in the cache\n    cached_result_str: Optional[str] = self.cache.get(self.name)\n    if cached_result_str is not None:\n        if isinstance(cached_result_str, list):\n            cached_result_str = json.dumps(cached_result_str)\n        cached_result: Optional[List[int]] = json.loads(cached_result_str)\n    else:\n        cached_result = None\n    if cached_result is not None:\n        self.app.update_terminal(f\"\\nFound manga: {self.name} in cache.\")\n        Logger.INFO(f\"Found manga: {self.name} in cache.\")\n        return cached_result\n\n    while self.retry_count &lt; self.max_retries:\n        Logger.DEBUG(\n            f\"Retry count: {self.retry_count}. Max retries: {self.max_retries}.\"\n        )\n        if self.name != \"Skipping Title\":\n            Logger.INFO(f\"Searching for manga: {self.name}.\")\n            try:\n                if not self.search_and_process_manga():\n                    break\n            except (\n                pymoe.utils.errors.serverError,  # pylint: disable=E1101\n                IndexError,\n                KeyError,\n            ) as e:\n                self.handle_search_errors(e)\n                continue\n            if not self.matches:\n                self.app.update_terminal(\n                    f\"\\nNo search results found for '{self.name}'.\"\n                )\n                Logger.WARNING(f\"No search results found for '{self.name}'.\")\n                no_manga_found.append((self.name, self.last_chapter_read))\n                Logger.DEBUG(f\"Added '{self.name}' to the list of manga not found.\")\n                break\n            self.get_id_list()\n            self.print_details()\n            self.handle_no_ids_found()\n            if self.id_list:\n                result = self.id_list\n                Logger.DEBUG(f\"Got list of IDs: {result}.\")\n                # Add the manga ID to the cache\n                self.cache.set(self.name, result)\n                break\n        else:\n            self.app.update_terminal(\"\\nSkipping a title...\")\n            Logger.INFO(\"Skipping a title.\")\n            break\n    else:\n        self.app.update_terminal(\n            f\"Failed to get manga ID for '{self.name}' after {self.max_retries} retries.\"\n        )\n        Logger.ERROR(\n            f\"Failed to get manga ID for '{self.name}' after {self.max_retries} retries.\"\n        )\n    return result\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.handle_no_ids_found","title":"handle_no_ids_found","text":"<pre><code>handle_no_ids_found() -&gt; None\n</code></pre> <p>Handles the case where no IDs are found.</p> <p>This method prints a message and adds the name and the last chapter read to the list of manga not found if no IDs are found.</p> Source code in <code>AnilistMangaUpdater/Manga/manga_search.py</code> <pre><code>def handle_no_ids_found(self) -&gt; None:\n    \"\"\"\n    Handles the case where no IDs are found.\n\n    This method prints a message and adds the name and the last chapter read\n    to the list of manga not found if no IDs are found.\n    \"\"\"\n    Logger.INFO(\"Function handle_no_ids_found called.\")\n    if not self.id_list:\n        self.app.update_terminal(f\"\\nNo manga found for '{self.name}'.\")\n        Logger.WARNING(f\"No manga found for '{self.name}'.\")\n        no_manga_found.append((self.name, self.last_chapter_read))\n        Logger.DEBUG(f\"Added '{self.name}' to the list of manga not found.\")\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.handle_search_errors","title":"handle_search_errors","text":"<pre><code>handle_search_errors(error: Exception) -&gt; None\n</code></pre> <p>Handles errors that occur during the search.</p> PARAMETER DESCRIPTION <code>error</code> <p>The error that occurred.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>AnilistMangaUpdater/Manga/manga_search.py</code> <pre><code>def handle_search_errors(self, error: Exception) -&gt; None:\n    \"\"\"\n    Handles errors that occur during the search.\n\n    Parameters:\n        error (Exception): The error that occurred.\n    \"\"\"\n    if isinstance(error, pymoe.utils.errors.serverError):  # pylint: disable=E1101\n        self.handle_server_error(error)\n    elif isinstance(error, IndexError):\n        self.app.update_terminal(f\"\\nNo search results found for '{self.name}'.\")\n        Logger.WARNING(f\"No search results found for '{self.name}'.\")\n        no_manga_found.append((self.name, self.last_chapter_read))\n        Logger.DEBUG(f\"Added '{self.name}' to the list of manga not found.\")\n    elif isinstance(error, KeyError):\n        self.app.update_terminal(\n            f\"\\nFailed to get data for '{self.name}', retrying...\"\n        )\n        Logger.ERROR(f\"Failed to get data for '{self.name}', retrying.\")\n        self.retry_count += 1 if \"Too Many Requests\" in str(error) else 0\n        Logger.DEBUG(f\"Incremented retry count to {self.retry_count}.\")\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.handle_server_error","title":"handle_server_error","text":"<pre><code>handle_server_error(e: Exception) -&gt; None\n</code></pre> <p>Handles server errors.</p> <p>This method checks if the error is a \"Too Many Requests\" error. If so, it waits for a delay and increments the retry count. If the error is not a \"Too Many Requests\" error, it prints an error message.</p> PARAMETER DESCRIPTION <code>e</code> <p>The server error to handle.</p> <p> TYPE: <code>Exception</code> </p> Source code in <code>AnilistMangaUpdater/Manga/manga_search.py</code> <pre><code>def handle_server_error(self, e: Exception) -&gt; None:\n    \"\"\"\n    Handles server errors.\n\n    This method checks if the error is a \"Too Many Requests\" error.\n    If so, it waits for a delay and increments the retry count.\n    If the error is not a \"Too Many Requests\" error, it prints an error message.\n\n    Parameters:\n        e (Exception): The server error to handle.\n    \"\"\"\n    Logger.INFO(\"Function handle_server_error called.\")\n    if \"Too Many Requests\" in str(e):\n        self.app.update_terminal(\n            f\"\\nToo Many Requests For Pymoe. Retrying in {self.delay} seconds...\"\n        )\n        Logger.WARNING(\"Too Many Requests For Pymoe. Retrying.\")\n        time.sleep(self.delay)\n        self.retry_count += 1\n        Logger.DEBUG(f\"Incremented retry count to {self.retry_count}.\")\n    else:\n        self.app.update_terminal(\n            f\"An unexpected server error occurred for {self.name}: {e}\"\n        )\n        Logger.ERROR(f\"An unexpected server error occurred for {self.name}: {e}\")\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.print_details","title":"print_details","text":"<pre><code>print_details() -&gt; None\n</code></pre> <p>Prints the details of the matches.</p> <p>This method prints the list of IDs, the romaji title, the English title, and the Anilist URL for the matches with a positive match score.</p> Source code in <code>AnilistMangaUpdater/Manga/manga_search.py</code> <pre><code>def print_details(self) -&gt; None:\n    \"\"\"\n    Prints the details of the matches.\n\n    This method prints the list of IDs, the romaji title, the English title,\n    and the Anilist URL for the matches with a positive match score.\n    \"\"\"\n    Logger.INFO(\"Function print_details called.\")\n    if self.id_list:\n        self.app.update_terminal(f\"\\nList of IDs for {self.name} : {self.id_list}\")\n        Logger.DEBUG(f\"Printed list of IDs for {self.name}.\")\n        romaji_title = self.matches[0][1][\"title\"][\"romaji\"]\n        english_title = self.matches[0][1][\"title\"][\"english\"]\n        self.app.update_terminal(f\"Romaji Title: {romaji_title}\")\n        Logger.DEBUG(f\"Printed Romaji title: {romaji_title}.\")\n        self.app.update_terminal(f\"English Title: {english_title}\")\n        Logger.DEBUG(f\"Printed English title: {english_title}.\")\n        for match, manga_item in self.matches:\n            if match:\n                self.app.update_terminal(f\"Anilist URL: {manga_item['siteUrl']}\")\n                Logger.DEBUG(f\"Printed Anilist URL: {manga_item['siteUrl']}.\")\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.process_manga_item","title":"process_manga_item","text":"<pre><code>process_manga_item(manga_item: dict) -&gt; None\n</code></pre> <p>Processes a manga item from the search results.</p> <p>This method gets the English and Romaji titles and the synonyms from the manga item. It processes them and checks if they match the name. If they do, it adds the manga item to the matches.</p> PARAMETER DESCRIPTION <code>manga_item</code> <p>The manga item to process.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>AnilistMangaUpdater/Manga/manga_search.py</code> <pre><code>def process_manga_item(self, manga_item: dict) -&gt; None:\n    \"\"\"\n    Processes a manga item from the search results.\n\n    This method gets the English and Romaji titles and the synonyms from the manga item.\n    It processes them and checks if they match the name.\n    If they do, it adds the manga item to the matches.\n\n    Parameters:\n        manga_item (dict): The manga item to process.\n    \"\"\"\n    Logger.INFO(\"Function process_manga_item called.\")\n    title = manga_item[\"title\"]\n    match = False\n    if \"english\" in title and title[\"english\"]:\n        english_title = self.process_title(title[\"english\"])\n        match = match or self.check_title_match(english_title)\n        Logger.DEBUG(f\"Checked English title: {english_title}. Match: {match}\")\n    if \"romaji\" in title and title[\"romaji\"]:\n        romaji_title = self.process_title(title[\"romaji\"])\n        match = match or self.check_title_match(romaji_title)\n        Logger.DEBUG(f\"Checked Romaji title: {romaji_title}. Match: {match}\")\n    if \"synonyms\" in manga_item:\n        for synonym in manga_item[\"synonyms\"]:\n            synonym = self.process_title(synonym)\n            match = match or self.check_title_match(synonym)\n            Logger.DEBUG(f\"Checked synonym: {synonym}. Match: {match}\")\n    if match:\n        self.matches.append((match, manga_item))\n        Logger.INFO(\"Match found. Added to matches.\")\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.process_title","title":"process_title  <code>staticmethod</code>","text":"<pre><code>process_title(title: str) -&gt; str\n</code></pre> <p>Processes the title by replacing certain characters.</p> PARAMETER DESCRIPTION <code>title</code> <p>The title to process.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The processed title.</p> <p> TYPE: <code>str</code> </p> Source code in <code>AnilistMangaUpdater/Manga/manga_search.py</code> <pre><code>@staticmethod\ndef process_title(title: str) -&gt; str:\n    \"\"\"\n    Processes the title by replacing certain characters.\n\n    Parameters:\n        title (str): The title to process.\n\n    Returns:\n        str: The processed title.\n    \"\"\"\n    Logger.INFO(\"Function process_title called.\")\n    Logger.DEBUG(f\"Processing title: {title}\")\n    title = title.replace(\"-\", \" \")\n    title = title.replace(\"\\u2019\", \"\\u0060\")\n    title = title.replace(\"`\", \"'\")\n    Logger.DEBUG(f\"Processed title: {title}\")\n    return title\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.search_and_process_manga","title":"search_and_process_manga","text":"<pre><code>search_and_process_manga() -&gt; bool\n</code></pre> <p>Searches for a manga and processes the search results.</p> RETURNS DESCRIPTION <code>bool</code> <p>True if the search was successful, False otherwise.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>AnilistMangaUpdater/Manga/manga_search.py</code> <pre><code>def search_and_process_manga(self) -&gt; bool:\n    \"\"\"\n    Searches for a manga and processes the search results.\n\n    Returns:\n        bool: True if the search was successful, False otherwise.\n    \"\"\"\n    manga = self.search_manga()\n    if manga:\n        Logger.DEBUG(f\"Search results for manga: {manga}.\")\n    if manga is None or not manga:\n        Logger.DEBUG(\"No search results for manga.\")\n        return False\n    for manga_item in manga:\n        self.process_manga_item(manga_item)\n    self.retry_count = 0  # Reset the retry count after a successful search\n    Logger.DEBUG(\"Reset retry count after a successful search.\")\n    return True\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.MangaSearch.search_manga","title":"search_manga","text":"<pre><code>search_manga()\n</code></pre> <p>Searches for the manga on Anilist.</p> RETURNS DESCRIPTION <code>list</code> <p>A list of manga items from the search results. If an error occurs, it returns None.</p> Source code in <code>AnilistMangaUpdater/Manga/manga_search.py</code> <pre><code>def search_manga(self):  # pylint: disable=R1710\n    \"\"\"\n    Searches for the manga on Anilist.\n\n    Returns:\n        list: A list of manga items from the search results. If an error occurs, it returns None.\n    \"\"\"\n    Logger.INFO(\"Function search_manga called.\")\n    max_retries = 5  # Maximum number of retries\n    for attempt in range(max_retries):  # pylint: disable=W0612\n        Logger.DEBUG(\n            f\"Attempt {attempt+1} of {max_retries} to search for manga: {self.name}\"\n        )\n        try:\n            result = pymoe.manga.search.anilist.manga(self.name)\n            Logger.DEBUG(f\"Search successful. Found {len(result)} results.\")\n            return result[:100]\n        except (\n            pymoe.utils.errors.serverError,\n            KeyError,\n        ) as e:  # pylint: disable=E1101\n            # Handle server error\n            Logger.ERROR(f\"Error encountered: {e}\")\n            if \"Too Many Requests\" in str(e):\n                self.app.update_terminal(\n                    f\"\\nToo Many Requests For Pymoe. Retrying in {self.delay} seconds...\"\n                )\n                Logger.WARNING(\"Too many requests. Delaying next attempt.\")\n                time.sleep(self.delay)\n                self.retry_count += 1\n            else:\n                self.app.update_terminal(\n                    f\"\\nAn unexpected error occurred for {self.name}: {e}. \"\n                    \"Retrying in 2 seconds...\"\n                )\n                Logger.WARNING(\"Unexpected error. Retrying in 2 seconds.\")\n                time.sleep(2)\n    self.app.update_terminal(\n        f\"Failed to search for {self.name} after {max_retries} attempts.\"\n    )\n    Logger.ERROR(f\"Failed to search for {self.name} after {max_retries} attempts.\")\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.Check_Title_Match","title":"Check_Title_Match","text":"<pre><code>Check_Title_Match(title: str, name: str) -&gt; bool\n</code></pre> <p>Checks if all words in the search name are in the title.</p> <p>This function removes punctuation from the title and the search name, splits them into words, and checks if all words in the search name are in the title.</p> PARAMETER DESCRIPTION <code>title</code> <p>The title to check.</p> <p> TYPE: <code>str</code> </p> <code>name</code> <p>The search name.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if all words in the search name are in the title, False otherwise.</p> <p> TYPE: <code>bool</code> </p> Source code in <code>AnilistMangaUpdater/Manga/manga_search.py</code> <pre><code>def Check_Title_Match(title: str, name: str) -&gt; bool:\n    \"\"\"\n    Checks if all words in the search name are in the title.\n\n    This function removes punctuation from the title and the search name,\n    splits them into words, and checks if all words in the search name\n    are in the title.\n\n    Parameters:\n        title (str): The title to check.\n        name (str): The search name.\n\n    Returns:\n        bool: True if all words in the search name are in the title, False otherwise.\n    \"\"\"\n    Logger.INFO(\"Function Check_Title_Match called.\")\n    Logger.DEBUG(f\"Checking if all words in '{name}' are in '{title}'.\")\n    # Remove punctuation from the title and the search name\n    title = title.translate(str.maketrans(\"\", \"\", string.punctuation))\n    name = name.translate(str.maketrans(\"\", \"\", string.punctuation))\n    Logger.DEBUG(f\"Removed punctuation from '{title}' and '{name}'.\")\n\n    # Split the title and the search name into words\n    title_words = set(title.lower().split())\n    name_words = set(name.lower().split())\n    Logger.DEBUG(f\"Split '{title}' and '{name}' into words.\")\n\n    # Check if all words in the search name are in the title\n    match = name_words.issubset(title_words)\n    Logger.DEBUG(f\"Match result: {match}\")\n    return match\n</code></pre>"},{"location":"Manga/MangaSearch/#AnilistMangaUpdater.Manga.manga_search.return_no_manga_found","title":"return_no_manga_found","text":"<pre><code>return_no_manga_found() -&gt; list[tuple[str, Union[int, None]]]\n</code></pre> <p>Returns the list of manga not found.</p> RETURNS DESCRIPTION <code>list</code> <p>A list of tuples containing the name and the last chapter read of the manga not found.</p> <p> TYPE: <code>list[tuple[str, Union[int, None]]]</code> </p> Source code in <code>AnilistMangaUpdater/Manga/manga_search.py</code> <pre><code>def return_no_manga_found() -&gt; list[tuple[str, Union[int, None]]]:\n    \"\"\"\n    Returns the list of manga not found.\n\n    Returns:\n        list: A list of tuples containing the name and the last chapter read of the manga not found.\n    \"\"\"\n    Logger.INFO(\"Function return_no_manga_found called.\")\n    return no_manga_found\n</code></pre>"},{"location":"Utils/Cache/","title":"Cache","text":"<p>This module contains the Cache class which provides a simple caching mechanism. It stores key-value pairs in a JSON file located in the Manga_Data directory.</p>"},{"location":"Utils/Cache/#AnilistMangaUpdater.Utils.cache.Cache","title":"Cache","text":"<pre><code>Cache(cache_file: str)\n</code></pre> <p>A simple caching class that stores key-value pairs in a JSON file.</p> ATTRIBUTE DESCRIPTION <code>cache_file</code> <p>The path to the file where the cache is stored.</p> <p> TYPE: <code>str</code> </p> <code>cache</code> <p>The cache data.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>AnilistMangaUpdater/Utils/cache.py</code> <pre><code>def __init__(self, cache_file: str) -&gt; None:\n    self.cache_file: str = cache_file\n    self.cache: dict = {}  # Initialize cache as an empty dictionary\n    Logger.INFO(f\"Cache initialized with file: {self.cache_file}\")\n    self.load_cache()\n</code></pre>"},{"location":"Utils/Cache/#AnilistMangaUpdater.Utils.cache.Cache.cache","title":"cache  <code>instance-attribute</code>","text":"<pre><code>cache: dict = {}\n</code></pre>"},{"location":"Utils/Cache/#AnilistMangaUpdater.Utils.cache.Cache.cache_file","title":"cache_file  <code>instance-attribute</code>","text":"<pre><code>cache_file: str = cache_file\n</code></pre>"},{"location":"Utils/Cache/#AnilistMangaUpdater.Utils.cache.Cache.get","title":"get","text":"<pre><code>get(key: str) -&gt; Union[str, None]\n</code></pre> <p>Gets a value from the cache.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key to get the value for.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>Union[str, None]</code> <p>The value for the key, or None if the key is not in the cache.</p> Source code in <code>AnilistMangaUpdater/Utils/cache.py</code> <pre><code>def get(self, key: str) -&gt; Union[str, None]:\n    \"\"\"\n    Gets a value from the cache.\n\n    Parameters:\n        key (str): The key to get the value for.\n\n    Returns:\n        The value for the key, or None if the key is not in the cache.\n    \"\"\"\n    Logger.INFO(f\"Getting value for key: {key} from cache.\")\n    value = self.cache.get(key)\n    if value is None:\n        Logger.WARNING(f\"No value found in cache for key: {key}.\")\n    else:\n        Logger.INFO(f\"Found value in cache for key: {key}.\")\n    return value\n</code></pre>"},{"location":"Utils/Cache/#AnilistMangaUpdater.Utils.cache.Cache.load_cache","title":"load_cache","text":"<pre><code>load_cache() -&gt; None\n</code></pre> <p>Loads the cache from a file.</p> Source code in <code>AnilistMangaUpdater/Utils/cache.py</code> <pre><code>def load_cache(self) -&gt; None:\n    \"\"\"\n    Loads the cache from a file.\n    \"\"\"\n    Logger.INFO(\"Loading cache from file.\")\n    try:\n        os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)\n        with open(self.cache_file, \"r\", encoding=\"utf-8\") as f:\n            self.cache.update(json.load(f))\n        Logger.INFO(\"Cache loaded successfully.\")\n    except FileNotFoundError:\n        Logger.WARNING(\n            \"Cache file not found. Initializing cache with default values.\"\n        )\n        if \"format_cache.json\" in self.cache_file:\n            self.cache.update(cache_format_dict)\n        else:\n            self.cache.update(cache_title_dict)\n        self.save_cache()\n</code></pre>"},{"location":"Utils/Cache/#AnilistMangaUpdater.Utils.cache.Cache.save_cache","title":"save_cache","text":"<pre><code>save_cache() -&gt; None\n</code></pre> <p>Saves the cache to a file.</p> Source code in <code>AnilistMangaUpdater/Utils/cache.py</code> <pre><code>def save_cache(self) -&gt; None:\n    \"\"\"\n    Saves the cache to a file.\n    \"\"\"\n    Logger.INFO(\"Saving cache to file.\")\n    os.makedirs(os.path.dirname(self.cache_file), exist_ok=True)\n    with open(self.cache_file, \"w\", encoding=\"utf-8\") as f:\n        json.dump(self.cache, f)\n    Logger.INFO(\"Cache saved successfully.\")\n</code></pre>"},{"location":"Utils/Cache/#AnilistMangaUpdater.Utils.cache.Cache.set","title":"set","text":"<pre><code>set(key: str, value: Any) -&gt; None\n</code></pre> <p>Sets a value in the cache and saves the cache to a file.</p> PARAMETER DESCRIPTION <code>key</code> <p>The key to set the value for.</p> <p> TYPE: <code>str</code> </p> <code>value</code> <p>The value to set.</p> <p> TYPE: <code>Any</code> </p> Source code in <code>AnilistMangaUpdater/Utils/cache.py</code> <pre><code>def set(self, key: str, value: Any) -&gt; None:\n    \"\"\"\n    Sets a value in the cache and saves the cache to a file.\n\n    Parameters:\n        key (str): The key to set the value for.\n        value: The value to set.\n    \"\"\"\n    Logger.INFO(f\"Setting value for key: {key} in cache.\")\n    self.cache[key] = value\n    self.save_cache()\n</code></pre>"},{"location":"Utils/Config/","title":"Config","text":"<p>This module contains functions for creating, saving, loading, and setting the configuration for the AniList API.</p>"},{"location":"Utils/Config/#AnilistMangaUpdater.Utils.Config.Get_Config","title":"Get_Config","text":"<pre><code>Get_Config(app: object) -&gt; None\n</code></pre> <p>Gets the configuration dictionary.</p> <p>This function loads the configuration dictionary and sets the environment variables with the values from the configuration dictionary.</p> PARAMETER DESCRIPTION <code>app</code> <p>The application object.</p> <p> TYPE: <code>App</code> </p> Source code in <code>AnilistMangaUpdater/Utils/Config.py</code> <pre><code>def Get_Config(app: object) -&gt; None:\n    \"\"\"\n    Gets the configuration dictionary.\n\n    This function loads the configuration dictionary and sets the environment variables\n    with the values from the configuration dictionary.\n\n    Parameters:\n        app (App): The application object.\n    \"\"\"\n    # Load the configuration dictionary from the file\n    Logger.INFO(\"Function Get_Config called.\")\n    config: Optional[dict] = load_config(\"config.json\")\n\n    if config:\n        # If the configuration dictionary is loaded successfully, print a message\n        app.update_terminal(\"Configuration file found.\")\n        Logger.INFO(\"Configuration file found.\")\n\n        # Set the environment variables with the values from the configuration dictionary\n        Set_Environment_Variables(config)\n        app.update_terminal(\"Environment variables set.\")\n        Logger.INFO(\"Environment variables set.\")\n    else:\n        # If the configuration dictionary is not loaded successfully, print a message\n        Logger.WARN(\"Configuration file not found.\")  # pylint: disable=E1101\n        message = (\n            \"\\nConfiguration file not found. Please use buttons on the left side \"\n            \"to set the Client, Secret ID's, as well as the Private value and number of Months\"\n        )\n        app.update_terminal(message)\n</code></pre>"},{"location":"Utils/Config/#AnilistMangaUpdater.Utils.Config.Set_Environment_Variables","title":"Set_Environment_Variables","text":"<pre><code>Set_Environment_Variables(config: dict) -&gt; None\n</code></pre> <p>Sets the environment variables with the values from the configuration dictionary.</p> PARAMETER DESCRIPTION <code>config</code> <p>The configuration dictionary.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>AnilistMangaUpdater/Utils/Config.py</code> <pre><code>def Set_Environment_Variables(config: dict) -&gt; None:\n    \"\"\"\n    Sets the environment variables with the values from the configuration dictionary.\n\n    Parameters:\n        config (dict): The configuration dictionary.\n    \"\"\"\n    Logger.INFO(\"Function Set_Environment_Variables called.\")\n    # Set the environment variables with the values from the configuration dictionary\n    for key, value in config.items():\n        if value is not None:\n            os.environ[key] = value\n            Logger.DEBUG(f\"Environment variable {key} set to {value}.\")\n    Logger.INFO(\"Finished setting environment variables.\")\n</code></pre>"},{"location":"Utils/Config/#AnilistMangaUpdater.Utils.Config.create_config","title":"create_config","text":"<pre><code>create_config(client: str, secret: str, token: Optional[str] = None, months: Optional[int] = None, private: Optional[bool] = None) -&gt; dict\n</code></pre> <p>Creates a configuration dictionary.</p> PARAMETER DESCRIPTION <code>client</code> <p>The client ID for the AniList API.</p> <p> TYPE: <code>str</code> </p> <code>secret</code> <p>The client secret for the AniList API.</p> <p> TYPE: <code>str</code> </p> <code>token</code> <p>The access token for the AniList API. Default is None.</p> <p> TYPE: <code>str</code> DEFAULT: <code>None</code> </p> <code>months</code> <p>The number of months to consider for the manga updates. Default is None.</p> <p> TYPE: <code>int</code> DEFAULT: <code>None</code> </p> <code>private</code> <p>The privacy setting for the manga updates. Default is None.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>None</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>The configuration dictionary.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>AnilistMangaUpdater/Utils/Config.py</code> <pre><code>def create_config(\n    client: str,\n    secret: str,\n    token: Optional[str] = None,\n    months: Optional[int] = None,\n    private: Optional[bool] = None,\n) -&gt; dict:\n    \"\"\"\n    Creates a configuration dictionary.\n\n    Parameters:\n        client (str): The client ID for the AniList API.\n        secret (str): The client secret for the AniList API.\n        token (str): The access token for the AniList API. Default is None.\n        months (int): The number of months to consider for the manga updates. Default is None.\n        private (bool): The privacy setting for the manga updates. Default is None.\n\n    Returns:\n        dict: The configuration dictionary.\n    \"\"\"\n    # Create and return the configuration dictionary directly\n    Logger.INFO(\"Function create_config called.\")\n    Logger.DEBUG(\n        f\"Parameters - client: {client}, \" f\"months: {months}, private: {private}\"\n    )\n    return {\n        \"ANILIST_CLIENT_ID\": client,\n        \"ANILIST_CLIENT_SECRET\": secret,\n        \"ACCESS_TOKEN\": token,\n        \"MONTHS\": months,\n        \"PRIVATE\": private,\n    }\n</code></pre>"},{"location":"Utils/Config/#AnilistMangaUpdater.Utils.Config.load_config","title":"load_config","text":"<pre><code>load_config(file_path: str) -&gt; Optional[dict[Union[str, Union[str, None]], None]]\n</code></pre> <p>Loads the configuration dictionary from a file.</p> PARAMETER DESCRIPTION <code>file_path</code> <p>The path to the configuration file.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>The configuration dictionary if the file is found, otherwise None.</p> <p> TYPE: <code>Optional[dict[Union[str, Union[str, None]], None]]</code> </p> Source code in <code>AnilistMangaUpdater/Utils/Config.py</code> <pre><code>def load_config(file_path: str) -&gt; Optional[dict[Union[str, Union[str, None]], None]]:\n    \"\"\"\n    Loads the configuration dictionary from a file.\n\n    Parameters:\n        file_path (str): The path to the configuration file.\n\n    Returns:\n        dict: The configuration dictionary if the file is found, otherwise None.\n    \"\"\"\n    Logger.INFO(\"Function load_config called.\")\n    Logger.DEBUG(f\"Attempting to load config from file: {file_path}\")\n    try:\n        # Open the configuration file in read mode with explicit encoding\n        with open(file_path, \"r\", encoding=\"utf-8\") as file:\n            # Load the configuration dictionary from the file\n            config = json.load(file)\n        Logger.INFO(\"Configuration loaded successfully.\")\n        # Return the configuration dictionary\n        return config\n    except FileNotFoundError:\n        # If the configuration file is not found, return None\n        Logger.WARN(  # pylint: disable=E1101\n            \"Configuration file not found. Returning None.\"\n        )\n        return None\n</code></pre>"},{"location":"Utils/Config/#AnilistMangaUpdater.Utils.Config.save_config","title":"save_config","text":"<pre><code>save_config(config: Union[dict[Union[str, None], None], None], file_path: str) -&gt; None\n</code></pre> <p>Saves the configuration dictionary to a file.</p> PARAMETER DESCRIPTION <code>config</code> <p>The configuration dictionary.</p> <p> TYPE: <code>dict</code> </p> <code>file_path</code> <p>The path to the configuration file.</p> <p> TYPE: <code>str</code> </p> Source code in <code>AnilistMangaUpdater/Utils/Config.py</code> <pre><code>def save_config(\n    config: Union[dict[Union[str, None], None], None], file_path: str\n) -&gt; None:\n    \"\"\"\n    Saves the configuration dictionary to a file.\n\n    Parameters:\n        config (dict): The configuration dictionary.\n        file_path (str): The path to the configuration file.\n    \"\"\"\n    # Open the configuration file in write mode with explicit encoding\n    Logger.INFO(\"Function save_config called.\")\n    Logger.DEBUG(f\"Saving config to file: {file_path}\")\n    with open(file_path, \"w\", encoding=\"utf-8\") as file:\n        # Write the configuration dictionary to the file in JSON format\n        json.dump(config, file, indent=4)\n    Logger.INFO(\"Config saved successfully.\")\n</code></pre>"},{"location":"Utils/Dictionaries/","title":"Dictionaries","text":"<p>This file contains the Python dictionaries that are used to store the alternative titles, format cache, and title cache.</p>"},{"location":"Utils/Dictionaries/#AnilistMangaUpdater.Utils.dictionaries.alternative_titles_dict","title":"alternative_titles_dict  <code>module-attribute</code>","text":"<pre><code>alternative_titles_dict = load(file)\n</code></pre>"},{"location":"Utils/Dictionaries/#AnilistMangaUpdater.Utils.dictionaries.alternative_titles_file","title":"alternative_titles_file  <code>module-attribute</code>","text":"<pre><code>alternative_titles_file: str = join(resources_path, 'alternative_titles.json')\n</code></pre>"},{"location":"Utils/Dictionaries/#AnilistMangaUpdater.Utils.dictionaries.base_path","title":"base_path  <code>module-attribute</code>","text":"<pre><code>base_path = dirname(dirname(base_path))\n</code></pre>"},{"location":"Utils/Dictionaries/#AnilistMangaUpdater.Utils.dictionaries.cache_format_dict","title":"cache_format_dict  <code>module-attribute</code>","text":"<pre><code>cache_format_dict = load(file)\n</code></pre>"},{"location":"Utils/Dictionaries/#AnilistMangaUpdater.Utils.dictionaries.cache_title_dict","title":"cache_title_dict  <code>module-attribute</code>","text":"<pre><code>cache_title_dict = load(file)\n</code></pre>"},{"location":"Utils/Dictionaries/#AnilistMangaUpdater.Utils.dictionaries.format_cache_file","title":"format_cache_file  <code>module-attribute</code>","text":"<pre><code>format_cache_file: str = join(resources_path, 'format_cache.json')\n</code></pre>"},{"location":"Utils/Dictionaries/#AnilistMangaUpdater.Utils.dictionaries.resources_path","title":"resources_path  <code>module-attribute</code>","text":"<pre><code>resources_path: str = join(base_path, 'Resources')\n</code></pre>"},{"location":"Utils/Dictionaries/#AnilistMangaUpdater.Utils.dictionaries.title_cache_file","title":"title_cache_file  <code>module-attribute</code>","text":"<pre><code>title_cache_file: str = join(resources_path, 'title_cache.json')\n</code></pre>"},{"location":"Utils/GetFromFile/","title":"GetFromFile","text":"<p>This module contains functions for reading manga data from a CSV file, getting the difference between the current and previous file, getting the manga names and their details, and printing the manga found in the CSV file.</p>"},{"location":"Utils/GetFromFile/#AnilistMangaUpdater.Utils.GetFromFile.alternative_titles_dict","title":"alternative_titles_dict  <code>module-attribute</code>","text":"<pre><code>alternative_titles_dict = Get_Alt_Titles_From_File(alternative_titles_dict)\n</code></pre>"},{"location":"Utils/GetFromFile/#AnilistMangaUpdater.Utils.GetFromFile.manga_names_chapters","title":"manga_names_chapters  <code>module-attribute</code>","text":"<pre><code>manga_names_chapters = {}\n</code></pre>"},{"location":"Utils/GetFromFile/#AnilistMangaUpdater.Utils.GetFromFile.Get_File_Diff","title":"Get_File_Diff","text":"<pre><code>Get_File_Diff(app: object) -&gt; Union[DataFrame, None]\n</code></pre> <p>Gets the difference between the current and previous file.</p> <p>This function reads the current file and checks if there is a previous file. If there is a previous file, it reads it. If the file is not found, it prints an error message.</p> PARAMETER DESCRIPTION <code>app</code> <p>The application object.</p> <p> TYPE: <code>App</code> </p> RETURNS DESCRIPTION <code>Union[DataFrame, None]</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Utils/GetFromFile.py</code> <pre><code>def Get_File_Diff(app: object) -&gt; Union[pd.DataFrame, None]:\n    \"\"\"\n    Gets the difference between the current and previous file.\n\n    This function reads the current file and checks if there is a previous file.\n    If there is a previous file, it reads it. If the file is not found, it prints\n    an error message.\n\n    Parameters:\n        app (App): The application object.\n\n    Returns:\n        None\n    \"\"\"\n    Logger.INFO(\"Function Get_File_Diff called.\")\n    global manga_names_chapters\n    df_previous = None\n    try:\n        manga_names_chapters = {}\n        # Read the current file\n        df = pd.read_csv(app.file_path)\n        # Check if there is a previous file\n        Logger.DEBUG(f\"Read current file: {app.file_path}\")\n        has_previous_file = app.previous_file_path != \"\"\n        if has_previous_file:\n            # If there is a previous file, read it\n            df_previous = pd.read_csv(app.previous_file_path)\n            Logger.DEBUG(f\"Read previous file: {app.previous_file_path}\")\n    except FileNotFoundError:\n        # If the file is not found, print an error message\n        app.update_terminal(\n            \"Error: Please browse for a kenmei export file. (Previous is Optional)\"\n        )\n        Logger.ERROR(\"FileNotFoundError encountered. Returning None.\")\n        return None\n\n    if has_previous_file and df_previous is not None:\n        df_diff = pd.merge(\n            df,\n            df_previous,\n            how=\"outer\",\n            indicator=True,\n            on=[\"title\", \"status\", \"last_chapter_read\", \"last_read_at\"],\n        )\n        df_diff = df_diff[df_diff[\"_merge\"] == \"left_only\"]\n        Logger.INFO(\"Returning difference between current and previous file.\")\n        return df_diff\n    Logger.INFO(\"Returning current file.\")\n    return df\n</code></pre>"},{"location":"Utils/GetFromFile/#AnilistMangaUpdater.Utils.GetFromFile.Get_Manga_Names","title":"Get_Manga_Names","text":"<pre><code>Get_Manga_Names(app: object, alt_titles_dict: dict)\n</code></pre> <p>Gets the manga names from a file and stores them in a dictionary.</p> <p>This function gets the difference between the current and previous file, iterates through each row in the file, and gets the title, last chapter read, status, and last read at from the row. It then gets the alternative title and adds it and its details to the manga_names_chapters dictionary.</p> PARAMETER DESCRIPTION <code>app</code> <p>The application object.</p> <p> TYPE: <code>App</code> </p> <code>alt_titles_dict</code> <p>A dictionary where keys are manga names and</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <p>None</p> Source code in <code>AnilistMangaUpdater/Utils/GetFromFile.py</code> <pre><code>def Get_Manga_Names(app: object, alt_titles_dict: dict):\n    \"\"\"\n    Gets the manga names from a file and stores them in a dictionary.\n\n    This function gets the difference between the current and previous file,\n    iterates through each row in the file, and gets the title, last chapter read,\n    status, and last read at from the row. It then gets the alternative title and\n    adds it and its details to the manga_names_chapters dictionary.\n\n    Parameters:\n        app (App): The application object.\n        alt_titles_dict (dict): A dictionary where keys are manga names and\n        values are alternative titles.\n\n    Returns:\n        None\n    \"\"\"\n    Logger.INFO(\"Function Get_Manga_Names called.\")\n    global manga_names_chapters\n    # Get the difference between the current and previous file\n    file = Get_File_Diff(app)\n    if file is not None:\n        try:\n            # Iterate through each row in the file\n            for row in file.itertuples():\n                # Get the title, last chapter read, status, and last read at from the row\n                title: str = str(row.title)\n                # Get the alternative title\n                alt_title: str = get_alternative_title(title, alt_titles_dict)\n                last_chapter_read = row.last_chapter_read\n                status = row.status\n                last_read_at = row.last_read_at\n                Logger.DEBUG(\n                    f\"Processing row: {title}, {last_chapter_read}, {status}, {last_read_at}\"\n                )\n\n                try:\n                    # Add the alternative title and its details to the manga_names_chapters dictionary\n                    manga_names_chapters[alt_title] = {\n                        \"last_chapter_read\": (\n                            int(last_chapter_read)\n                            if isinstance(last_chapter_read, (int, float, str))\n                            else None\n                        ),\n                        \"status\": status,\n                        \"last_read_at\": last_read_at,\n                    }\n                    Logger.DEBUG(\n                        f\"Added {alt_title} to manga_names_chapters dictionary.\"\n                    )\n                except (ValueError, AttributeError):\n                    # If no last chapter read, print a message and add the alternative title\n                    Logger.DEBUG(f\"Title: {alt_title}, Has no Last Chapter Read\")\n                    Logger.DEBUG(f\"Title: {alt_title}, Status: {status}\")\n                    app.update_terminal(f\"Title: {alt_title}, Has no Last Chapter Read\")\n                    app.update_terminal(status)\n                    if status in (\"plan_to_read\", \"on_hold\"):\n                        manga_names_chapters[alt_title] = {\"status\": status}\n                        Logger.DEBUG(\n                            f\"Added {alt_title} to manga_names_chapters dictionary \"\n                            f\"with status {status}.\"\n                        )\n        except AttributeError:\n            Logger.ERROR(\"AttributeError encountered. Returning None.\")\n            return None\n    else:\n        Logger.ERROR(\"File not found. Returning None.\")\n        return None\n\n    # Return the manga_names_chapters dictionary\n    Logger.INFO(\"Returning manga_names_chapters dictionary.\")\n    return manga_names_chapters\n</code></pre>"},{"location":"Utils/GetFromFile/#AnilistMangaUpdater.Utils.GetFromFile.Manga_Found_In_CSV","title":"Manga_Found_In_CSV","text":"<pre><code>Manga_Found_In_CSV(app: object) -&gt; None\n</code></pre> <p>Prints the manga found in the CSV file.</p> <p>This function gets the manga with the last chapter from the CSV file and prints the title, last chapter read, and last read at for each manga.</p> PARAMETER DESCRIPTION <code>app</code> <p>The application object.</p> <p> TYPE: <code>App</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Utils/GetFromFile.py</code> <pre><code>def Manga_Found_In_CSV(app: object) -&gt; None:  # pylint: disable=R1710\n    \"\"\"\n    Prints the manga found in the CSV file.\n\n    This function gets the manga with the last chapter from the CSV file and\n    prints the title, last chapter read, and last read at for each manga.\n\n    Parameters:\n        app (App): The application object.\n\n    Returns:\n        None\n    \"\"\"\n    Logger.INFO(\"Function Manga_Found_In_CSV called.\")\n    manga_with_last_chapter = Get_Manga_Names(app, alternative_titles_dict)\n    Logger.DEBUG(\"Retrieved manga with last chapter from CSV file.\")\n\n    with ThreadPoolExecutor(max_workers=1) as executor:\n        # Create a list to store the futures\n        futures: list = []\n\n        for title, details in manga_with_last_chapter.items():\n            # Submit the task to the executor\n            future = executor.submit(process_manga_details, title, details)\n            futures.append(future)\n\n        # Gather the results\n        messages: list = []\n        for future in as_completed(futures):\n            messages.append(future.result())\n\n        # Update the terminal\n        app.update_terminal(\"\\n\".join(messages))\n</code></pre>"},{"location":"Utils/GetFromFile/#AnilistMangaUpdater.Utils.GetFromFile.get_alternative_title","title":"get_alternative_title","text":"<pre><code>get_alternative_title(title: str, alt_titles_dict: dict) -&gt; str\n</code></pre> <p>Gets the alternative title of a manga.</p> <p>This function checks if a manga title is in a dictionary of alternative titles. If it is, it returns the alternative title. If it's not, it returns the original title.</p> PARAMETER DESCRIPTION <code>title</code> <p>The title of the manga.</p> <p> TYPE: <code>str</code> </p> <code>alt_titles_dict</code> <p>A dictionary of alternative titles.</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The alternative title if it exists, otherwise the original title.</p> <p> TYPE: <code>str</code> </p> Source code in <code>AnilistMangaUpdater/Utils/GetFromFile.py</code> <pre><code>def get_alternative_title(title: str, alt_titles_dict: dict) -&gt; str:\n    \"\"\"\n    Gets the alternative title of a manga.\n\n    This function checks if a manga title is in a dictionary of alternative titles.\n    If it is, it returns the alternative title. If it's not, it returns the original title.\n\n    Parameters:\n        title (str): The title of the manga.\n        alt_titles_dict (dict): A dictionary of alternative titles.\n\n    Returns:\n        str: The alternative title if it exists, otherwise the original title.\n    \"\"\"\n    Logger.INFO(\"Function get_alternative_title called.\")\n    # Check if the title is in the dictionary\n    if title in alt_titles_dict:\n        # If it is, return the alternative title\n        Logger.DEBUG(f\"Alternative title found for {title}.\")\n        return alt_titles_dict[title]\n    # If it's not, return the original title\n    Logger.DEBUG(f\"No alternative title found for {title}. Returning original title.\")\n    return title\n</code></pre>"},{"location":"Utils/GetFromFile/#AnilistMangaUpdater.Utils.GetFromFile.process_manga_details","title":"process_manga_details","text":"<pre><code>process_manga_details(title: str, details: dict) -&gt; str\n</code></pre> <p>Process the details of a manga.</p> <p>Args: title (str): The title of the manga. details (dict): A dictionary containing details about the manga.</p> <p>Returns: str: A formatted string containing the processed information.</p> Source code in <code>AnilistMangaUpdater/Utils/GetFromFile.py</code> <pre><code>def process_manga_details(title: str, details: dict) -&gt; str:\n    \"\"\"\n    Process the details of a manga.\n\n    Args:\n    title (str): The title of the manga.\n    details (dict): A dictionary containing details about the manga.\n\n    Returns:\n    str: A formatted string containing the processed information.\n    \"\"\"\n    last_chapter_read = details.get(\"last_chapter_read\")\n    last_read_at = details.get(\"last_read_at\")\n    Logger.DEBUG(f\"Processing manga: {title}\")\n    return f\"Title: {title}, Last Chapter Read: {last_chapter_read}, Last Read At: {last_read_at}\"\n</code></pre>"},{"location":"Utils/Log/","title":"Log","text":"<p>This module provides a custom Logger class for logging messages with additional information.</p> <p>The Logger class provides static methods for logging messages at different levels (INFO, DEBUG, WARNING, ERROR, CRITICAL). Each log message includes the current time, file name, function name, and line number.</p>"},{"location":"Utils/Log/#AnilistMangaUpdater.Utils.log.MAIN_DIR","title":"MAIN_DIR  <code>module-attribute</code>","text":"<pre><code>MAIN_DIR = dirname(dirname(dirname(abspath(__file__))))\n</code></pre>"},{"location":"Utils/Log/#AnilistMangaUpdater.Utils.log.timestamp","title":"timestamp  <code>module-attribute</code>","text":"<pre><code>timestamp = strftime('%Y-%m-%d_%H-%M-%S')\n</code></pre>"},{"location":"Utils/Log/#AnilistMangaUpdater.Utils.log.Logger","title":"Logger","text":"<p>A custom Logger class for logging messages with additional information.</p> <p>This Logger provides static methods for logging messages at different levels (INFO, DEBUG, WARNING, ERROR, CRITICAL). Each log message includes the current time, file name, function name, and line number.</p>"},{"location":"Utils/Log/#AnilistMangaUpdater.Utils.log.Logger.CRITICAL","title":"CRITICAL  <code>staticmethod</code>","text":"<pre><code>CRITICAL(message: str) -&gt; None\n</code></pre> <p>Logs a critical message.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to log.</p> <p> TYPE: <code>str</code> </p> Source code in <code>AnilistMangaUpdater/Utils/log.py</code> <pre><code>@staticmethod\ndef CRITICAL(message: str) -&gt; None:\n    \"\"\"\n    Logs a critical message.\n\n    Parameters:\n        message (str): The message to log.\n    \"\"\"\n    Logger.log(message, logging.CRITICAL)\n</code></pre>"},{"location":"Utils/Log/#AnilistMangaUpdater.Utils.log.Logger.DEBUG","title":"DEBUG  <code>staticmethod</code>","text":"<pre><code>DEBUG(message: str) -&gt; None\n</code></pre> <p>Logs a debug message.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to log.</p> <p> TYPE: <code>str</code> </p> Source code in <code>AnilistMangaUpdater/Utils/log.py</code> <pre><code>@staticmethod\ndef DEBUG(message: str) -&gt; None:\n    \"\"\"\n    Logs a debug message.\n\n    Parameters:\n        message (str): The message to log.\n    \"\"\"\n    Logger.log(message, logging.DEBUG)\n</code></pre>"},{"location":"Utils/Log/#AnilistMangaUpdater.Utils.log.Logger.ERROR","title":"ERROR  <code>staticmethod</code>","text":"<pre><code>ERROR(message: str) -&gt; None\n</code></pre> <p>Logs an error message.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to log.</p> <p> TYPE: <code>str</code> </p> Source code in <code>AnilistMangaUpdater/Utils/log.py</code> <pre><code>@staticmethod\ndef ERROR(message: str) -&gt; None:\n    \"\"\"\n    Logs an error message.\n\n    Parameters:\n        message (str): The message to log.\n    \"\"\"\n    Logger.log(message, logging.ERROR)\n</code></pre>"},{"location":"Utils/Log/#AnilistMangaUpdater.Utils.log.Logger.INFO","title":"INFO  <code>staticmethod</code>","text":"<pre><code>INFO(message: str) -&gt; None\n</code></pre> <p>Logs an informational message.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to log.</p> <p> TYPE: <code>str</code> </p> Source code in <code>AnilistMangaUpdater/Utils/log.py</code> <pre><code>@staticmethod\ndef INFO(message: str) -&gt; None:\n    \"\"\"\n    Logs an informational message.\n\n    Parameters:\n        message (str): The message to log.\n    \"\"\"\n    Logger.log(message, logging.INFO)\n</code></pre>"},{"location":"Utils/Log/#AnilistMangaUpdater.Utils.log.Logger.WARNING","title":"WARNING  <code>staticmethod</code>","text":"<pre><code>WARNING(message: str) -&gt; None\n</code></pre> <p>Logs a warning message.</p> <p>Parameters: message (str): The message to log.</p> Source code in <code>AnilistMangaUpdater/Utils/log.py</code> <pre><code>@staticmethod\ndef WARNING(message: str) -&gt; None:\n    \"\"\"\n    Logs a warning message.\n\n    Parameters:\n    message (str): The message to log.\n    \"\"\"\n    Logger.log(message, logging.WARNING)\n</code></pre>"},{"location":"Utils/Log/#AnilistMangaUpdater.Utils.log.Logger.log","title":"log  <code>staticmethod</code>","text":"<pre><code>log(message: str, level: int) -&gt; None\n</code></pre> <p>Logs a message with the current time, file name, function name, and line number.</p> PARAMETER DESCRIPTION <code>message</code> <p>The message to log.</p> <p> TYPE: <code>str</code> </p> <code>level</code> <p>The logging level of the message (e.g., logging.INFO, logging.DEBUG).</p> <p> TYPE: <code>int</code> </p> Source code in <code>AnilistMangaUpdater/Utils/log.py</code> <pre><code>@staticmethod\ndef log(message: str, level: int) -&gt; None:\n    \"\"\"\n    Logs a message with the current time, file name, function name, and line number.\n\n    Parameters:\n        message (str): The message to log.\n        level (int): The logging level of the message (e.g., logging.INFO, logging.DEBUG).\n    \"\"\"\n    # Get the current frame\n    frame = inspect.currentframe()\n    for _ in range(3):\n        if frame is not None:\n            frame = frame.f_back\n\n    if frame is not None:\n        func = frame.f_code\n\n        # Prepare the log message\n        log_message = (\n            f\"Level: {logging.getLevelName(level)}, \"\n            f\"File: ..\\\\{os.path.relpath(func.co_filename, start=MAIN_DIR)}, \"\n            f\"Function: {func.co_name}, Line: {frame.f_lineno}, \"\n            f\"Message: {message}\"\n        )\n\n        # Log the message at the appropriate level\n        logging.log(level, log_message)\n    else:\n        logging.error(\"Error: Could not get the current frame.\")\n</code></pre>"},{"location":"Utils/Log/#AnilistMangaUpdater.Utils.log.Logger.manage_log_files","title":"manage_log_files  <code>staticmethod</code>","text":"<pre><code>manage_log_files(max_logs: int) -&gt; None\n</code></pre> <p>Manages the number of log files in the logs directory.</p> PARAMETER DESCRIPTION <code>max_logs</code> <p>The maximum number of log files to keep.</p> <p> TYPE: <code>int</code> </p> Source code in <code>AnilistMangaUpdater/Utils/log.py</code> <pre><code>@staticmethod\ndef manage_log_files(max_logs: int) -&gt; None:\n    \"\"\"\n    Manages the number of log files in the logs directory.\n\n    Parameters:\n        max_logs (int): The maximum number of log files to keep.\n    \"\"\"\n    log_files = glob.glob(\"logs/*.log\")\n    log_files.sort(key=os.path.getctime)\n\n    while len(log_files) &gt; max_logs:\n        os.remove(log_files.pop(0))\n</code></pre>"},{"location":"Utils/Log/#AnilistMangaUpdater.Utils.log.Logger.setup","title":"setup  <code>staticmethod</code>","text":"<pre><code>setup(max_logs: int = 15) -&gt; None\n</code></pre> <p>Sets up the logger to print to both the terminal and a file.</p> PARAMETER DESCRIPTION <code>max_logs</code> <p>The maximum number of log files to keep.</p> <p> TYPE: <code>int</code> DEFAULT: <code>15</code> </p> Source code in <code>AnilistMangaUpdater/Utils/log.py</code> <pre><code>@staticmethod\ndef setup(max_logs: int = 15) -&gt; None:\n    \"\"\"\n    Sets up the logger to print to both the terminal and a file.\n\n    Parameters:\n        max_logs (int): The maximum number of log files to keep.\n    \"\"\"\n    handlers: List[Handler] = [\n        logging.FileHandler(\"logs/latest.log\", encoding=\"utf-8\"),\n        logging.StreamHandler(stream=sys.stdout),\n    ]\n    logging.basicConfig(\n        level=logging.DEBUG, format=\"%(asctime)s, %(message)s\", handlers=handlers\n    )\n\n    logging.getLogger().handlers = handlers\n    Logger.manage_log_files(max_logs)\n</code></pre>"},{"location":"Utils/WriteToFile/","title":"WriteToFile","text":"<p>This module contains functions to manage and write data to files.</p> <p>It includes functions to save and retrieve alternative titles of manga, manage files in a directory, write names of not found manga and manga with multiple IDs to files, and write the number of chapters updated to a file.</p>"},{"location":"Utils/WriteToFile/#AnilistMangaUpdater.Utils.WriteToFile.directory","title":"directory  <code>module-attribute</code>","text":"<pre><code>directory: str = 'Manga_Data'\n</code></pre>"},{"location":"Utils/WriteToFile/#AnilistMangaUpdater.Utils.WriteToFile.Get_Alt_Titles_From_File","title":"Get_Alt_Titles_From_File","text":"<pre><code>Get_Alt_Titles_From_File(alternative_titles_dict: dict) -&gt; dict\n</code></pre> <p>Retrieves alternative titles from a file.</p> <p>This function checks if the file 'alternative_titles.json' exists in the specified directory. If it does, it opens the file and loads the dictionary from it. If the file does not exist, it saves the alternative titles to the file and then opens it to load the dictionary.</p> PARAMETER DESCRIPTION <code>alternative_titles_dict</code> <p>A dictionary of alternative titles.</p> <p> TYPE: <code>dict</code> </p> <code>directory</code> <p>The directory where the file is located.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>dict</code> <p>The dictionary of alternative titles loaded from the file.</p> <p> TYPE: <code>dict</code> </p> Source code in <code>AnilistMangaUpdater/Utils/WriteToFile.py</code> <pre><code>def Get_Alt_Titles_From_File(alternative_titles_dict: dict) -&gt; dict:\n    \"\"\"\n    Retrieves alternative titles from a file.\n\n    This function checks if the file 'alternative_titles.json' exists in the\n    specified directory. If it does, it opens the file and loads the dictionary\n    from it. If the file does not exist, it saves the alternative titles to the\n    file and then opens it to load the dictionary.\n\n    Parameters:\n        alternative_titles_dict (dict): A dictionary of alternative titles.\n        directory (str): The directory where the file is located.\n\n    Returns:\n        dict: The dictionary of alternative titles loaded from the file.\n    \"\"\"\n    Logger.INFO(\"Function Get_Alt_Titles_From_File called.\")\n    filename = f\"{directory}/alternative_titles.json\"\n    # Check if the directory exists, if not, create it\n    create_directory_if_not_exists(directory)\n    # Check if the file exists\n    if os.path.exists(filename):\n        Logger.DEBUG(f\"File {filename} exists.\")\n        # Open the file to read\n        with open(filename, \"r\", encoding=\"utf-8\") as alt_titles_file:\n            Logger.DEBUG(f\"Reading from file: {filename}\")\n            # Load the dictionary from the file\n            alternative_titles_dict = json.load(alt_titles_file)\n            Logger.INFO(\"Loaded dictionary from file.\")\n            return alternative_titles_dict\n    # If the file does not exist, save the dictionary to the file and then read it\n    else:\n        Logger.WARNING(f\"File {filename} does not exist. Creating it now.\")\n        Save_Alt_Titles_To_File(alternative_titles_dict)\n        # Open the file to read\n        with open(filename, \"r\", encoding=\"utf-8\") as alt_titles_file:\n            Logger.DEBUG(f\"Reading from file: {filename}\")\n            # Load the dictionary from the file\n            alternative_titles_dict = json.load(alt_titles_file)\n            Logger.INFO(\"Loaded dictionary from file.\")\n            return alternative_titles_dict\n</code></pre>"},{"location":"Utils/WriteToFile/#AnilistMangaUpdater.Utils.WriteToFile.Save_Alt_Titles_To_File","title":"Save_Alt_Titles_To_File","text":"<pre><code>Save_Alt_Titles_To_File(alternative_titles_dict: dict) -&gt; None\n</code></pre> <p>Saves alternative titles to a file.</p> PARAMETER DESCRIPTION <code>alternative_titles_dict</code> <p>A dictionary of alternative titles.</p> <p> TYPE: <code>dict</code> </p> <code>directory</code> <p>The directory where the file will be saved.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Utils/WriteToFile.py</code> <pre><code>def Save_Alt_Titles_To_File(alternative_titles_dict: dict) -&gt; None:\n    \"\"\"\n    Saves alternative titles to a file.\n\n    Parameters:\n        alternative_titles_dict (dict): A dictionary of alternative titles.\n        directory (str): The directory where the file will be saved.\n\n    Returns:\n        None\n    \"\"\"\n    Logger.INFO(\"Function Save_Alt_Titles_To_File called.\")\n    # Check if directory exists, if not, create it\n    create_directory_if_not_exists(directory)\n    # Open a file to write, this will overwrite the file if it already exists\n    with open(\n        f\"{directory}/alternative_titles.json\", \"w\", encoding=\"utf-8\"\n    ) as alt_titles_file:\n        Logger.DEBUG(f\"Writing to file: {directory}/alternative_titles.json\")\n        json.dump(alternative_titles_dict, alt_titles_file)\n    Logger.INFO(\"Finished writing to file.\")\n</code></pre>"},{"location":"Utils/WriteToFile/#AnilistMangaUpdater.Utils.WriteToFile.create_directory_and_get_timestamp","title":"create_directory_and_get_timestamp","text":"<pre><code>create_directory_and_get_timestamp(dir_path: str) -&gt; str\n</code></pre> <p>Checks if the given directory exists, creates it if it doesn't, and then returns the current timestamp.</p> PARAMETER DESCRIPTION <code>dir_path</code> <p>The path of the directory to check or create.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>str</code> <p>The current timestamp in the format \"YYYY-MM-DD_HH-MM-SS\".</p> <p> TYPE: <code>str</code> </p> Source code in <code>AnilistMangaUpdater/Utils/WriteToFile.py</code> <pre><code>def create_directory_and_get_timestamp(dir_path: str) -&gt; str:\n    \"\"\"\n    Checks if the given directory exists, creates it if it doesn't,\n    and then returns the current timestamp.\n\n    Args:\n        dir_path (str): The path of the directory to check or create.\n\n    Returns:\n        str: The current timestamp in the format \"YYYY-MM-DD_HH-MM-SS\".\n    \"\"\"\n    # Check if directory exists, if not, create it\n    create_directory_if_not_exists(dir_path)\n    # Get current timestamp\n    timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d_%H-%M-%S\")\n    Logger.DEBUG(f\"Current timestamp: {timestamp}\")\n    return timestamp\n</code></pre>"},{"location":"Utils/WriteToFile/#AnilistMangaUpdater.Utils.WriteToFile.create_directory_if_not_exists","title":"create_directory_if_not_exists","text":"<pre><code>create_directory_if_not_exists(dir_path: str) -&gt; None\n</code></pre> <p>Checks if the given directory exists, creates it if it doesn't.</p> PARAMETER DESCRIPTION <code>dir_path</code> <p>The path of the directory to check or create.</p> <p> TYPE: <code>str</code> </p> Source code in <code>AnilistMangaUpdater/Utils/WriteToFile.py</code> <pre><code>def create_directory_if_not_exists(dir_path: str) -&gt; None:\n    \"\"\"\n    Checks if the given directory exists, creates it if it doesn't.\n\n    Args:\n        dir_path (str): The path of the directory to check or create.\n    \"\"\"\n    if not os.path.exists(dir_path):\n        Logger.WARNING(f\"Directory {dir_path} does not exist. Creating it now.\")\n        os.makedirs(dir_path)\n</code></pre>"},{"location":"Utils/WriteToFile/#AnilistMangaUpdater.Utils.WriteToFile.formatter_multiple_ids","title":"formatter_multiple_ids","text":"<pre><code>formatter_multiple_ids(multiple_id_manga_names: dict) -&gt; list\n</code></pre> <p>Formats manga names with multiple IDs for writing to a file.</p> PARAMETER DESCRIPTION <code>multiple_id_manga_names</code> <p>A dictionary where keys are manga names and</p> <p> TYPE: <code>dict</code> </p> RETURNS DESCRIPTION <code>list</code> <p>A list of strings formatted for writing to a file.</p> <p> TYPE: <code>list</code> </p> Source code in <code>AnilistMangaUpdater/Utils/WriteToFile.py</code> <pre><code>def formatter_multiple_ids(multiple_id_manga_names: dict) -&gt; list:\n    \"\"\"\n    Formats manga names with multiple IDs for writing to a file.\n\n    Parameters:\n        multiple_id_manga_names (dict): A dictionary where keys are manga names and\n        values are lists of tuples, each containing an ID and the last chapter read.\n\n    Returns:\n        list: A list of strings formatted for writing to a file.\n    \"\"\"\n    # Initialize lines list with header\n    lines = [\"Duplicate Manga Names and IDs:\\n\"]\n    # If no multiple ID manga names, append message to lines\n    if not multiple_id_manga_names:\n        lines.append(\"No Manga Names with Multiple IDs Found\\n\")\n    else:\n        # Loop through each manga name and its IDs\n        for manga_name, ids in multiple_id_manga_names.items():\n            # Get actual IDs from the tuples\n            actual_ids = [id_tuple[0] for id_tuple in ids]\n            # Get last chapter read if available, else set to \"Unknown\"\n            last_chapter_read = ids[0][1] if len(ids[0]) &gt; 1 else \"Unknown\"\n            # Append manga name, IDs, and last chapter read to lines\n            formatted_ids = \", \".join(map(str, actual_ids))\n            lines.append(\n                f\"{manga_name} ID's: {formatted_ids}, \"\n                f\"Last Chapter Read: {last_chapter_read}\\n\"\n            )\n            # Append Anilist URLs for each ID to lines\n            lines.extend(\n                [\n                    f\"Anilist URL: https://anilist.co/manga/{manga_id}\\n\"\n                    for manga_id in actual_ids\n                ]\n            )\n            # Append a newline to separate each manga\n            lines.append(\"\\n\")\n    return lines\n</code></pre>"},{"location":"Utils/WriteToFile/#AnilistMangaUpdater.Utils.WriteToFile.formatter_not_found","title":"formatter_not_found","text":"<pre><code>formatter_not_found(not_found_manga_names: list) -&gt; list\n</code></pre> <p>Formats not found manga names for writing to a file.</p> PARAMETER DESCRIPTION <code>not_found_manga_names</code> <p>A list of tuples, where each tuple contains a</p> <p> TYPE: <code>list</code> </p> RETURNS DESCRIPTION <code>list</code> <p>A list of strings formatted for writing to a file.</p> <p> TYPE: <code>list</code> </p> Source code in <code>AnilistMangaUpdater/Utils/WriteToFile.py</code> <pre><code>def formatter_not_found(not_found_manga_names: list) -&gt; list:\n    \"\"\"\n    Formats not found manga names for writing to a file.\n\n    Parameters:\n        not_found_manga_names (list): A list of tuples, where each tuple contains a\n        manga name and the last chapter read.\n\n    Returns:\n        list: A list of strings formatted for writing to a file.\n    \"\"\"\n    # Initialize lines list with header\n    lines = [\"Manga Names with No IDs Found:\\n\"]\n    # If no not found manga names, append message to lines\n    if not not_found_manga_names:\n        Logger.INFO(\"No Manga Names with No IDs Found\")\n        lines.append(\"No Manga Names with No IDs Found\\n\")\n    else:\n        Logger.INFO(\"Writing Manga Names with No IDs Found\")\n        # Loop through each not found manga name\n        for name, last_chapter_read in not_found_manga_names:\n            Logger.DEBUG(f\"Writing data for manga: {name}\")\n            # Create search link for the manga name\n            search_link = (\n                f\"https://anilist.co/search/manga?search={name.replace(' ', '%20')}\"\n            )\n            # Write manga name, last chapter read, and search link to file\n            lines.append(\n                f\"{name} - Last Chapter Read: {last_chapter_read}, Search Link: {search_link}\\n\"\n            )\n    return lines\n</code></pre>"},{"location":"Utils/WriteToFile/#AnilistMangaUpdater.Utils.WriteToFile.manage_files","title":"manage_files","text":"<pre><code>manage_files(dir_path: str, file_type: str) -&gt; None\n</code></pre> <p>Manages files in a directory by deleting the oldest file if there are more than 5.</p> <p>This function gets a list of all files of the specified type in the directory, sorted by modification time. If there are more than 5 files, it deletes the oldest file.</p> PARAMETER DESCRIPTION <code>dir_path</code> <p>The directory where the files are located.</p> <p> TYPE: <code>str</code> </p> <code>file_type</code> <p>The type of the files to manage.</p> <p> TYPE: <code>str</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Utils/WriteToFile.py</code> <pre><code>def manage_files(dir_path: str, file_type: str) -&gt; None:\n    \"\"\"\n    Manages files in a directory by deleting the oldest file if there are more than 5.\n\n    This function gets a list of all files of the specified type in the directory,\n    sorted by modification time. If there are more than 5 files, it deletes the oldest file.\n\n    Parameters:\n        dir_path (str): The directory where the files are located.\n        file_type (str): The type of the files to manage.\n\n    Returns:\n        None\n    \"\"\"\n    Logger.INFO(\"Function manage_files called.\")\n    # Get a list of all files of the specified type in the directory sorted by modification time\n    files = sorted(glob.glob(f\"{dir_path}/{file_type}_*\"), key=os.path.getmtime)\n    Logger.DEBUG(f\"Found {len(files)} {file_type} files in {dir_path}.\")\n    # If there are more than 5 files, delete the oldest file\n    if len(files) &gt; 5:\n        Logger.WARNING(\n            f\"More than 5 {file_type} files found. Deleting oldest file: {files[0]}\"\n        )\n        os.remove(files[0])\n    else:\n        Logger.INFO(\"No files to delete.\")\n</code></pre>"},{"location":"Utils/WriteToFile/#AnilistMangaUpdater.Utils.WriteToFile.write_chapters_updated_to_file","title":"write_chapters_updated_to_file","text":"<pre><code>write_chapters_updated_to_file(filename: str, data: int) -&gt; None\n</code></pre> <p>Appends data to a chapters updated file.</p> PARAMETER DESCRIPTION <code>filename</code> <p>The name of the file to append to.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>The number of updated chapters.</p> <p> TYPE: <code>int</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Utils/WriteToFile.py</code> <pre><code>def write_chapters_updated_to_file(filename: str, data: int) -&gt; None:\n    \"\"\"\n    Appends data to a chapters updated file.\n\n    Parameters:\n        filename (str): The name of the file to append to.\n        data (int): The number of updated chapters.\n\n    Returns:\n        None\n    \"\"\"\n    Logger.INFO(\n        f\"Function write_chapters_updated_to_file called with filename: {filename}\"\n    )\n    # Check if directory exists, if not, create it\n    create_directory_if_not_exists(\"Chapters-Updated\")\n    # Open a file to append\n    with open(f\"Chapters-Updated/{filename}.txt\", \"a\", encoding=\"utf-8\") as file:\n        Logger.DEBUG(f\"Appending to file: Chapters-Updated/{filename}.txt\")\n        timestamp = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n        file.write(f\"{timestamp} | Chapters Updated: {data}\\n\")\n    Logger.INFO(\"Finished appending to file.\")\n</code></pre>"},{"location":"Utils/WriteToFile/#AnilistMangaUpdater.Utils.WriteToFile.write_to_file","title":"write_to_file","text":"<pre><code>write_to_file(filename: str, data: Optional[Union[list, dict]], formatter) -&gt; None\n</code></pre> <p>Writes data to a file.</p> PARAMETER DESCRIPTION <code>filename</code> <p>The name of the file to write to.</p> <p> TYPE: <code>str</code> </p> <code>data</code> <p>The data to write to the file.</p> <p> TYPE: <code>list or dict</code> </p> <code>formatter</code> <p>A function that formats the data into a string.</p> <p> TYPE: <code>function</code> </p> RETURNS DESCRIPTION <code>None</code> <p>None</p> Source code in <code>AnilistMangaUpdater/Utils/WriteToFile.py</code> <pre><code>def write_to_file(filename: str, data: Optional[Union[list, dict]], formatter) -&gt; None:\n    \"\"\"\n    Writes data to a file.\n\n    Parameters:\n        filename (str): The name of the file to write to.\n        data (list or dict): The data to write to the file.\n        formatter (function): A function that formats the data into a string.\n\n    Returns:\n        None\n    \"\"\"\n    Logger.INFO(f\"Function write_to_file called with filename: {filename}\")\n    timestamp = create_directory_and_get_timestamp(directory)\n    # Open a file to write\n    with open(f\"{directory}/{filename}_{timestamp}.txt\", \"w\", encoding=\"utf-8\") as file:\n        Logger.DEBUG(f\"Writing to file: {directory}/{filename}_{timestamp}.txt\")\n        # Write formatted data to the file\n        file.writelines(formatter(data))\n    Logger.INFO(\"Finished writing to file.\")\n    # Manage files in the directory\n    manage_files(directory, filename)\n    Logger.INFO(\"Managed files in directory.\")\n</code></pre>"}]}